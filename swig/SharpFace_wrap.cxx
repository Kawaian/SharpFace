/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.10
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif



#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_LaandmrkDetector(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_LaandmrkDetector(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_LaandmrkDetector(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13




    // C++ API

    #include "CCNF_patch_expert.h"
    #include "LandmarkDetectionValidator.h"
    #include "LandmarkDetectorFunc.h"
    #include "LandmarkDetectorModel.h"
    #include "LandmarkDetectorParameters.h"
    #include "LandmarkDetectorUtils.h"
    #include "Patch_experts.h"
    #include "PAW.h"
    #include "PDM.h"
    #include "SVR_patch_expert.h"


#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


SWIGINTERN void SWIG_CSharpException(int code, const char *msg) {
  if (code == SWIG_ValueError) {
    SWIG_CSharpExceptionArgumentCodes exception_code = SWIG_CSharpArgumentOutOfRangeException;
    SWIG_CSharpSetPendingExceptionArgument(exception_code, msg, 0);
  } else {
    SWIG_CSharpExceptionCodes exception_code = SWIG_CSharpApplicationException;
    switch(code) {
    case SWIG_MemoryError:
      exception_code = SWIG_CSharpOutOfMemoryException;
      break;
    case SWIG_IndexError:
      exception_code = SWIG_CSharpIndexOutOfRangeException;
      break;
    case SWIG_DivisionByZero:
      exception_code = SWIG_CSharpDivideByZeroException;
      break;
    case SWIG_IOError:
      exception_code = SWIG_CSharpIOException;
      break;
    case SWIG_OverflowError:
      exception_code = SWIG_CSharpOverflowException;
      break;
    case SWIG_RuntimeError:
    case SWIG_TypeError:
    case SWIG_SyntaxError:
    case SWIG_SystemError:
    case SWIG_UnknownError:
    default:
      exception_code = SWIG_CSharpApplicationException;
      break;
    }
    SWIG_CSharpSetPendingException(exception_code, msg);
  }
}


#include <stdexcept>


#include <utility>


#include <map>
#include <algorithm>
#include <stdexcept>


#include <string>

SWIGINTERN std::vector< int > *new_std_vector_Sl_int_Sg___SWIG_2(int capacity){
        std::vector< int >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< int >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN int std_vector_Sl_int_Sg__getitemcopy(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN int const &std_vector_Sl_int_Sg__getitem(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__setitem(std::vector< int > *self,int index,int const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__AddRange(std::vector< int > *self,std::vector< int > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__GetRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< int >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Insert(std::vector< int > *self,int index,int const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__InsertRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveAt(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__Repeat(int const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< int >(count, value);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_0(std::vector< int > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_1(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__SetRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Contains(std::vector< int > *self,int const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_int_Sg__IndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_int_Sg__LastIndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Remove(std::vector< int > *self,int const &value){
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< float > *new_std_vector_Sl_float_Sg___SWIG_2(int capacity){
        std::vector< float >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< float >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN float std_vector_Sl_float_Sg__getitemcopy(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN float const &std_vector_Sl_float_Sg__getitem(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__setitem(std::vector< float > *self,int index,float const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__AddRange(std::vector< float > *self,std::vector< float > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< float > *std_vector_Sl_float_Sg__GetRange(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< float >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_float_Sg__Insert(std::vector< float > *self,int index,float const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__InsertRange(std::vector< float > *self,int index,std::vector< float > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__RemoveAt(std::vector< float > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_float_Sg__RemoveRange(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< float > *std_vector_Sl_float_Sg__Repeat(float const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< float >(count, value);
      }
SWIGINTERN void std_vector_Sl_float_Sg__Reverse__SWIG_0(std::vector< float > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_float_Sg__Reverse__SWIG_1(std::vector< float > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_float_Sg__SetRange(std::vector< float > *self,int index,std::vector< float > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_float_Sg__Contains(std::vector< float > *self,float const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_float_Sg__IndexOf(std::vector< float > *self,float const &value){
        int index = -1;
        std::vector< float >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_float_Sg__LastIndexOf(std::vector< float > *self,float const &value){
        int index = -1;
        std::vector< float >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_float_Sg__Remove(std::vector< float > *self,float const &value){
        std::vector< float >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< double > *new_std_vector_Sl_double_Sg___SWIG_2(int capacity){
        std::vector< double >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< double >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN double std_vector_Sl_double_Sg__getitemcopy(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN double const &std_vector_Sl_double_Sg__getitem(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__setitem(std::vector< double > *self,int index,double const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__AddRange(std::vector< double > *self,std::vector< double > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__GetRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< double >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Insert(std::vector< double > *self,int index,double const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__InsertRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveAt(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__Repeat(double const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< double >(count, value);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_0(std::vector< double > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_1(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__SetRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Contains(std::vector< double > *self,double const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_double_Sg__IndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_double_Sg__LastIndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Remove(std::vector< double > *self,double const &value){
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< std::string > *new_std_vector_Sl_std_string_Sg___SWIG_2(int capacity){
        std::vector< std::string >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::string >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::string std_vector_Sl_std_string_Sg__getitemcopy(std::vector< std::string > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::string const &std_vector_Sl_std_string_Sg__getitem(std::vector< std::string > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__setitem(std::vector< std::string > *self,int index,std::string const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__AddRange(std::vector< std::string > *self,std::vector< std::string > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::string > *std_vector_Sl_std_string_Sg__GetRange(std::vector< std::string > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::string >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__Insert(std::vector< std::string > *self,int index,std::string const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__InsertRange(std::vector< std::string > *self,int index,std::vector< std::string > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__RemoveAt(std::vector< std::string > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__RemoveRange(std::vector< std::string > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::string > *std_vector_Sl_std_string_Sg__Repeat(std::string const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::string >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__Reverse__SWIG_0(std::vector< std::string > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__Reverse__SWIG_1(std::vector< std::string > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_string_Sg__SetRange(std::vector< std::string > *self,int index,std::vector< std::string > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_std_string_Sg__Contains(std::vector< std::string > *self,std::string const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_std_string_Sg__IndexOf(std::vector< std::string > *self,std::string const &value){
        int index = -1;
        std::vector< std::string >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_std_string_Sg__LastIndexOf(std::vector< std::string > *self,std::string const &value){
        int index = -1;
        std::vector< std::string >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_std_string_Sg__Remove(std::vector< std::string > *self,std::string const &value){
        std::vector< std::string >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< cv::Point > *new_std_vector_Sl_cv_Point_Sg___SWIG_2(int capacity){
        std::vector< cv::Point >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Point >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Point std_vector_Sl_cv_Point_Sg__getitemcopy(std::vector< cv::Point > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Point const &std_vector_Sl_cv_Point_Sg__getitem(std::vector< cv::Point > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__setitem(std::vector< cv::Point > *self,int index,cv::Point const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__AddRange(std::vector< cv::Point > *self,std::vector< cv::Point > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Point > *std_vector_Sl_cv_Point_Sg__GetRange(std::vector< cv::Point > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Point >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__Insert(std::vector< cv::Point > *self,int index,cv::Point const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__InsertRange(std::vector< cv::Point > *self,int index,std::vector< cv::Point > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__RemoveAt(std::vector< cv::Point > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__RemoveRange(std::vector< cv::Point > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Point > *std_vector_Sl_cv_Point_Sg__Repeat(cv::Point const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Point >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__Reverse__SWIG_0(std::vector< cv::Point > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__Reverse__SWIG_1(std::vector< cv::Point > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Point_Sg__SetRange(std::vector< cv::Point > *self,int index,std::vector< cv::Point > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::pair< cv::Point,cv::Point > > *new_std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::pair< cv::Point,cv::Point > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::pair< cv::Point,cv::Point > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::pair< cv::Point,cv::Point > std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__getitemcopy(std::vector< std::pair< cv::Point,cv::Point > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::pair< cv::Point,cv::Point > const &std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__getitem(std::vector< std::pair< cv::Point,cv::Point > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__setitem(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,std::pair< cv::Point,cv::Point > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__AddRange(std::vector< std::pair< cv::Point,cv::Point > > *self,std::vector< std::pair< cv::Point,cv::Point > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::pair< cv::Point,cv::Point > > *std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__GetRange(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::pair< cv::Point,cv::Point > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Insert(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,std::pair< cv::Point,cv::Point > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__InsertRange(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,std::vector< std::pair< cv::Point,cv::Point > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__RemoveAt(std::vector< std::pair< cv::Point,cv::Point > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__RemoveRange(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::pair< cv::Point,cv::Point > > *std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Repeat(std::pair< cv::Point,cv::Point > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::pair< cv::Point,cv::Point > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Reverse__SWIG_0(std::vector< std::pair< cv::Point,cv::Point > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Reverse__SWIG_1(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__SetRange(std::vector< std::pair< cv::Point,cv::Point > > *self,int index,std::vector< std::pair< cv::Point,cv::Point > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< cv::Point2d > *new_std_vector_Sl_cv_Point2d_Sg___SWIG_2(int capacity){
        std::vector< cv::Point2d >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Point2d >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Point2d std_vector_Sl_cv_Point2d_Sg__getitemcopy(std::vector< cv::Point2d > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Point2d const &std_vector_Sl_cv_Point2d_Sg__getitem(std::vector< cv::Point2d > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__setitem(std::vector< cv::Point2d > *self,int index,cv::Point2d const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__AddRange(std::vector< cv::Point2d > *self,std::vector< cv::Point2d > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Point2d > *std_vector_Sl_cv_Point2d_Sg__GetRange(std::vector< cv::Point2d > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Point2d >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__Insert(std::vector< cv::Point2d > *self,int index,cv::Point2d const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__InsertRange(std::vector< cv::Point2d > *self,int index,std::vector< cv::Point2d > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__RemoveAt(std::vector< cv::Point2d > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__RemoveRange(std::vector< cv::Point2d > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Point2d > *std_vector_Sl_cv_Point2d_Sg__Repeat(cv::Point2d const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Point2d >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__Reverse__SWIG_0(std::vector< cv::Point2d > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__Reverse__SWIG_1(std::vector< cv::Point2d > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Point2d_Sg__SetRange(std::vector< cv::Point2d > *self,int index,std::vector< cv::Point2d > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::pair< cv::Point2d,cv::Point2d > > *new_std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::pair< cv::Point2d,cv::Point2d > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::pair< cv::Point2d,cv::Point2d > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::pair< cv::Point2d,cv::Point2d > std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__getitemcopy(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::pair< cv::Point2d,cv::Point2d > const &std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__getitem(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__setitem(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,std::pair< cv::Point2d,cv::Point2d > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__AddRange(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,std::vector< std::pair< cv::Point2d,cv::Point2d > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::pair< cv::Point2d,cv::Point2d > > *std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__GetRange(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::pair< cv::Point2d,cv::Point2d > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Insert(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,std::pair< cv::Point2d,cv::Point2d > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__InsertRange(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,std::vector< std::pair< cv::Point2d,cv::Point2d > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__RemoveAt(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__RemoveRange(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::pair< cv::Point2d,cv::Point2d > > *std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Repeat(std::pair< cv::Point2d,cv::Point2d > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::pair< cv::Point2d,cv::Point2d > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Reverse__SWIG_0(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Reverse__SWIG_1(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__SetRange(std::vector< std::pair< cv::Point2d,cv::Point2d > > *self,int index,std::vector< std::pair< cv::Point2d,cv::Point2d > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< cv::Rect_< double > > *new_std_vector_Sl_cv_Rect__Sl_double_Sg__Sg___SWIG_2(int capacity){
        std::vector< cv::Rect_< double > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Rect_< double > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Rect_< double > std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__getitemcopy(std::vector< cv::Rect_< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Rect_< double > const &std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__getitem(std::vector< cv::Rect_< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__setitem(std::vector< cv::Rect_< double > > *self,int index,cv::Rect_< double > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__AddRange(std::vector< cv::Rect_< double > > *self,std::vector< cv::Rect_< double > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Rect_< double > > *std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__GetRange(std::vector< cv::Rect_< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Rect_< double > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Insert(std::vector< cv::Rect_< double > > *self,int index,cv::Rect_< double > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__InsertRange(std::vector< cv::Rect_< double > > *self,int index,std::vector< cv::Rect_< double > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__RemoveAt(std::vector< cv::Rect_< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__RemoveRange(std::vector< cv::Rect_< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Rect_< double > > *std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Repeat(cv::Rect_< double > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Rect_< double > >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Reverse__SWIG_0(std::vector< cv::Rect_< double > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Reverse__SWIG_1(std::vector< cv::Rect_< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__SetRange(std::vector< cv::Rect_< double > > *self,int index,std::vector< cv::Rect_< double > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< int > > *new_std_vector_Sl_std_vector_Sl_int_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< int > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< int > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< int > std_vector_Sl_std_vector_Sl_int_Sg__Sg__getitemcopy(std::vector< std::vector< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< int > const &std_vector_Sl_std_vector_Sl_int_Sg__Sg__getitem(std::vector< std::vector< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__setitem(std::vector< std::vector< int > > *self,int index,std::vector< int > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__AddRange(std::vector< std::vector< int > > *self,std::vector< std::vector< int > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< int > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__GetRange(std::vector< std::vector< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< int > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__Insert(std::vector< std::vector< int > > *self,int index,std::vector< int > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__InsertRange(std::vector< std::vector< int > > *self,int index,std::vector< std::vector< int > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__RemoveAt(std::vector< std::vector< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__RemoveRange(std::vector< std::vector< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< int > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__Repeat(std::vector< int > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< int > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< int > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__SetRange(std::vector< std::vector< int > > *self,int index,std::vector< std::vector< int > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< float > > *new_std_vector_Sl_std_vector_Sl_float_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< float > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< float > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< float > std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitemcopy(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< float > const &std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitem(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__setitem(std::vector< std::vector< float > > *self,int index,std::vector< float > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__AddRange(std::vector< std::vector< float > > *self,std::vector< std::vector< float > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< float > > *std_vector_Sl_std_vector_Sl_float_Sg__Sg__GetRange(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< float > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Insert(std::vector< std::vector< float > > *self,int index,std::vector< float > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__InsertRange(std::vector< std::vector< float > > *self,int index,std::vector< std::vector< float > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveAt(std::vector< std::vector< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveRange(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< float > > *std_vector_Sl_std_vector_Sl_float_Sg__Sg__Repeat(std::vector< float > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< float > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< float > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_float_Sg__Sg__SetRange(std::vector< std::vector< float > > *self,int index,std::vector< std::vector< float > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< cv::Mat< float > > *new_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg___SWIG_2(int capacity){
        std::vector< cv::Mat< float > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Mat< float > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Mat< float > std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__getitemcopy(std::vector< cv::Mat< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Mat< float > const &std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__getitem(std::vector< cv::Mat< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__setitem(std::vector< cv::Mat< float > > *self,int index,cv::Mat< float > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__AddRange(std::vector< cv::Mat< float > > *self,std::vector< cv::Mat< float > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Mat< float > > *std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__GetRange(std::vector< cv::Mat< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Mat< float > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Insert(std::vector< cv::Mat< float > > *self,int index,cv::Mat< float > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__InsertRange(std::vector< cv::Mat< float > > *self,int index,std::vector< cv::Mat< float > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__RemoveAt(std::vector< cv::Mat< float > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__RemoveRange(std::vector< cv::Mat< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Mat< float > > *std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Repeat(cv::Mat< float > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Mat< float > >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Reverse__SWIG_0(std::vector< cv::Mat< float > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Reverse__SWIG_1(std::vector< cv::Mat< float > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__SetRange(std::vector< cv::Mat< float > > *self,int index,std::vector< cv::Mat< float > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< cv::Mat< double > > *new_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg___SWIG_2(int capacity){
        std::vector< cv::Mat< double > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Mat< double > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Mat< double > std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__getitemcopy(std::vector< cv::Mat< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Mat< double > const &std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__getitem(std::vector< cv::Mat< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__setitem(std::vector< cv::Mat< double > > *self,int index,cv::Mat< double > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__AddRange(std::vector< cv::Mat< double > > *self,std::vector< cv::Mat< double > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Mat< double > > *std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__GetRange(std::vector< cv::Mat< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Mat< double > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Insert(std::vector< cv::Mat< double > > *self,int index,cv::Mat< double > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__InsertRange(std::vector< cv::Mat< double > > *self,int index,std::vector< cv::Mat< double > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__RemoveAt(std::vector< cv::Mat< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__RemoveRange(std::vector< cv::Mat< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Mat< double > > *std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Repeat(cv::Mat< double > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Mat< double > >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Reverse__SWIG_0(std::vector< cv::Mat< double > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Reverse__SWIG_1(std::vector< cv::Mat< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__SetRange(std::vector< cv::Mat< double > > *self,int index,std::vector< cv::Mat< double > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< cv::Mat< int > > *new_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg___SWIG_2(int capacity){
        std::vector< cv::Mat< int > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< cv::Mat< int > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN cv::Mat< int > std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__getitemcopy(std::vector< cv::Mat< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN cv::Mat< int > const &std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__getitem(std::vector< cv::Mat< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__setitem(std::vector< cv::Mat< int > > *self,int index,cv::Mat< int > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__AddRange(std::vector< cv::Mat< int > > *self,std::vector< cv::Mat< int > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< cv::Mat< int > > *std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__GetRange(std::vector< cv::Mat< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< cv::Mat< int > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Insert(std::vector< cv::Mat< int > > *self,int index,cv::Mat< int > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__InsertRange(std::vector< cv::Mat< int > > *self,int index,std::vector< cv::Mat< int > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__RemoveAt(std::vector< cv::Mat< int > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__RemoveRange(std::vector< cv::Mat< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< cv::Mat< int > > *std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Repeat(cv::Mat< int > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< cv::Mat< int > >(count, value);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Reverse__SWIG_0(std::vector< cv::Mat< int > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Reverse__SWIG_1(std::vector< cv::Mat< int > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__SetRange(std::vector< cv::Mat< int > > *self,int index,std::vector< cv::Mat< int > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::map< int,cv::Mat< int > >::mapped_type const &std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__getitem(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int > >::key_type const &key){
        std::map< int, cv::Mat< int >, std::less< int > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__setitem(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int > >::key_type const &key,std::map< int,cv::Mat< int > >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__ContainsKey(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int > >::key_type const &key){
        std::map< int, cv::Mat< int >, std::less< int > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__Add(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int > >::key_type const &key,std::map< int,cv::Mat< int > >::mapped_type const &val){
        std::map< int, cv::Mat< int >, std::less< int > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< int, cv::Mat< int > >(key, val));
      }
SWIGINTERN bool std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__Remove(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int > >::key_type const &key){
        std::map< int, cv::Mat< int >, std::less< int > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< int,cv::Mat< int >,std::less< int > >::iterator *std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__create_iterator_begin(std::map< int,cv::Mat< int > > *self){
        return new std::map< int, cv::Mat< int >, std::less< int > >::iterator(self->begin());
      }
SWIGINTERN std::map< int,cv::Mat< int > >::key_type const &std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__get_next_key(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int >,std::less< int > >::iterator *swigiterator){
        std::map< int, cv::Mat< int >, std::less< int > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__destroy_iterator(std::map< int,cv::Mat< int > > *self,std::map< int,cv::Mat< int >,std::less< int > >::iterator *swigiterator){
        delete swigiterator;
      }
SWIGINTERN std::map< float,cv::Mat< float > >::mapped_type const &std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__getitem(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float > >::key_type const &key){
        std::map< float, cv::Mat< float >, std::less< float > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__setitem(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float > >::key_type const &key,std::map< float,cv::Mat< float > >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__ContainsKey(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float > >::key_type const &key){
        std::map< float, cv::Mat< float >, std::less< float > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__Add(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float > >::key_type const &key,std::map< float,cv::Mat< float > >::mapped_type const &val){
        std::map< float, cv::Mat< float >, std::less< float > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< float, cv::Mat< float > >(key, val));
      }
SWIGINTERN bool std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__Remove(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float > >::key_type const &key){
        std::map< float, cv::Mat< float >, std::less< float > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< float,cv::Mat< float >,std::less< float > >::iterator *std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__create_iterator_begin(std::map< float,cv::Mat< float > > *self){
        return new std::map< float, cv::Mat< float >, std::less< float > >::iterator(self->begin());
      }
SWIGINTERN std::map< float,cv::Mat< float > >::key_type const &std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__get_next_key(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float >,std::less< float > >::iterator *swigiterator){
        std::map< float, cv::Mat< float >, std::less< float > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__destroy_iterator(std::map< float,cv::Mat< float > > *self,std::map< float,cv::Mat< float >,std::less< float > >::iterator *swigiterator){
        delete swigiterator;
      }
SWIGINTERN std::map< double,cv::Mat< double > >::mapped_type const &std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__getitem(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double > >::key_type const &key){
        std::map< double, cv::Mat< double >, std::less< double > >::iterator iter = self->find(key);
        if (iter != self->end())
          return iter->second;
        else
          throw std::out_of_range("key not found");
      }
SWIGINTERN void std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__setitem(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double > >::key_type const &key,std::map< double,cv::Mat< double > >::mapped_type const &x){
        (*self)[key] = x;
      }
SWIGINTERN bool std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__ContainsKey(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double > >::key_type const &key){
        std::map< double, cv::Mat< double >, std::less< double > >::iterator iter = self->find(key);
        return iter != self->end();
      }
SWIGINTERN void std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__Add(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double > >::key_type const &key,std::map< double,cv::Mat< double > >::mapped_type const &val){
        std::map< double, cv::Mat< double >, std::less< double > >::iterator iter = self->find(key);
        if (iter != self->end())
          throw std::out_of_range("key already exists");
        self->insert(std::pair< double, cv::Mat< double > >(key, val));
      }
SWIGINTERN bool std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__Remove(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double > >::key_type const &key){
        std::map< double, cv::Mat< double >, std::less< double > >::iterator iter = self->find(key);
        if (iter != self->end()) {
          self->erase(iter);
          return true;
        }                
        return false;
      }
SWIGINTERN std::map< double,cv::Mat< double >,std::less< double > >::iterator *std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__create_iterator_begin(std::map< double,cv::Mat< double > > *self){
        return new std::map< double, cv::Mat< double >, std::less< double > >::iterator(self->begin());
      }
SWIGINTERN std::map< double,cv::Mat< double > >::key_type const &std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__get_next_key(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double >,std::less< double > >::iterator *swigiterator){
        std::map< double, cv::Mat< double >, std::less< double > >::iterator iter = *swigiterator;
        (*swigiterator)++;
        return (*iter).first;
      }
SWIGINTERN void std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__destroy_iterator(std::map< double,cv::Mat< double > > *self,std::map< double,cv::Mat< double >,std::less< double > >::iterator *swigiterator){
        delete swigiterator;
      }
SWIGINTERN std::vector< std::vector< cv::Mat< int > > > *new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< cv::Mat< int > > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< cv::Mat< int > > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< cv::Mat< int > > std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__getitemcopy(std::vector< std::vector< cv::Mat< int > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< cv::Mat< int > > const &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__getitem(std::vector< std::vector< cv::Mat< int > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__setitem(std::vector< std::vector< cv::Mat< int > > > *self,int index,std::vector< cv::Mat< int > > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__AddRange(std::vector< std::vector< cv::Mat< int > > > *self,std::vector< std::vector< cv::Mat< int > > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< cv::Mat< int > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__GetRange(std::vector< std::vector< cv::Mat< int > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< cv::Mat< int > > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Insert(std::vector< std::vector< cv::Mat< int > > > *self,int index,std::vector< cv::Mat< int > > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__InsertRange(std::vector< std::vector< cv::Mat< int > > > *self,int index,std::vector< std::vector< cv::Mat< int > > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__RemoveAt(std::vector< std::vector< cv::Mat< int > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__RemoveRange(std::vector< std::vector< cv::Mat< int > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< cv::Mat< int > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Repeat(std::vector< cv::Mat< int > > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< cv::Mat< int > > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< cv::Mat< int > > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< cv::Mat< int > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__SetRange(std::vector< std::vector< cv::Mat< int > > > *self,int index,std::vector< std::vector< cv::Mat< int > > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< cv::Mat< double > > > *new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< cv::Mat< double > > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< cv::Mat< double > > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< cv::Mat< double > > std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__getitemcopy(std::vector< std::vector< cv::Mat< double > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< cv::Mat< double > > const &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__getitem(std::vector< std::vector< cv::Mat< double > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__setitem(std::vector< std::vector< cv::Mat< double > > > *self,int index,std::vector< cv::Mat< double > > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__AddRange(std::vector< std::vector< cv::Mat< double > > > *self,std::vector< std::vector< cv::Mat< double > > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< cv::Mat< double > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__GetRange(std::vector< std::vector< cv::Mat< double > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< cv::Mat< double > > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Insert(std::vector< std::vector< cv::Mat< double > > > *self,int index,std::vector< cv::Mat< double > > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__InsertRange(std::vector< std::vector< cv::Mat< double > > > *self,int index,std::vector< std::vector< cv::Mat< double > > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__RemoveAt(std::vector< std::vector< cv::Mat< double > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__RemoveRange(std::vector< std::vector< cv::Mat< double > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< cv::Mat< double > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Repeat(std::vector< cv::Mat< double > > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< cv::Mat< double > > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< cv::Mat< double > > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< cv::Mat< double > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__SetRange(std::vector< std::vector< cv::Mat< double > > > *self,int index,std::vector< std::vector< cv::Mat< double > > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN std::vector< std::vector< cv::Mat< float > > > *new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< cv::Mat< float > > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< cv::Mat< float > > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< cv::Mat< float > > std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__getitemcopy(std::vector< std::vector< cv::Mat< float > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< cv::Mat< float > > const &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__getitem(std::vector< std::vector< cv::Mat< float > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__setitem(std::vector< std::vector< cv::Mat< float > > > *self,int index,std::vector< cv::Mat< float > > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__AddRange(std::vector< std::vector< cv::Mat< float > > > *self,std::vector< std::vector< cv::Mat< float > > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< cv::Mat< float > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__GetRange(std::vector< std::vector< cv::Mat< float > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< cv::Mat< float > > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Insert(std::vector< std::vector< cv::Mat< float > > > *self,int index,std::vector< cv::Mat< float > > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__InsertRange(std::vector< std::vector< cv::Mat< float > > > *self,int index,std::vector< std::vector< cv::Mat< float > > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__RemoveAt(std::vector< std::vector< cv::Mat< float > > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__RemoveRange(std::vector< std::vector< cv::Mat< float > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< cv::Mat< float > > > *std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Repeat(std::vector< cv::Mat< float > > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< cv::Mat< float > > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< cv::Mat< float > > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< cv::Mat< float > > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__SetRange(std::vector< std::vector< cv::Mat< float > > > *self,int index,std::vector< std::vector< cv::Mat< float > > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_neuron_type_set(void * jarg1, int jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->neuron_type = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCNF_neuron_neuron_type_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result = (int) ((arg1)->neuron_type);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_norm_weights_set(void * jarg1, double jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->norm_weights = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CCNF_neuron_norm_weights_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result = (double) ((arg1)->norm_weights);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_bias_set(void * jarg1, double jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->bias = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CCNF_neuron_bias_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result = (double) ((arg1)->bias);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_weights_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  cv::Mat_< float > arg2 ;
  cv::Mat_< float > *argp2 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  argp2 = (cv::Mat_< float > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< float >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->weights = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_neuron_weights_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  cv::Mat_< float > result;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result =  ((arg1)->weights);
  jresult = new cv::Mat_< float >((const cv::Mat_< float > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_weights_dfts_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  std::map< int,cv::Mat_< double >,std::less< int > > *arg2 = (std::map< int,cv::Mat_< double >,std::less< int > > *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (std::map< int,cv::Mat_< double >,std::less< int > > *)jarg2; 
  if (arg1) (arg1)->weights_dfts = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_neuron_weights_dfts_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  std::map< int,cv::Mat_< double >,std::less< int > > *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result = (std::map< int,cv::Mat_< double >,std::less< int > > *)& ((arg1)->weights_dfts);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_alpha_set(void * jarg1, double jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->alpha = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CCNF_neuron_alpha_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  result = (double) ((arg1)->alpha);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CCNF_neuron__SWIG_0() {
  void * jresult ;
  LandmarkDetector::CCNF_neuron *result = 0 ;
  
  result = (LandmarkDetector::CCNF_neuron *)new LandmarkDetector::CCNF_neuron();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CCNF_neuron__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_neuron *arg1 = 0 ;
  LandmarkDetector::CCNF_neuron *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::CCNF_neuron const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::CCNF_neuron *)new LandmarkDetector::CCNF_neuron((LandmarkDetector::CCNF_neuron const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_Read(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  std::ifstream *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (std::ifstream *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  (arg1)->Read(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_neuron_Response(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< double > *arg3 = 0 ;
  cv::Mat *arg4 = 0 ;
  cv::Mat *arg5 = 0 ;
  cv::Mat_< float > *arg6 = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  arg5 = (cv::Mat *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  arg6 = (cv::Mat_< float > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->Response(*arg2,*arg3,*arg4,*arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CCNF_neuron(void * jarg1) {
  LandmarkDetector::CCNF_neuron *arg1 = (LandmarkDetector::CCNF_neuron *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_neuron *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_width_set(void * jarg1, int jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->width = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCNF_patch_expert_width_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (int) ((arg1)->width);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_height_set(void * jarg1, int jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->height = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCNF_patch_expert_height_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (int) ((arg1)->height);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_neurons_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< LandmarkDetector::CCNF_neuron > *arg2 = (std::vector< LandmarkDetector::CCNF_neuron > *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (std::vector< LandmarkDetector::CCNF_neuron > *)jarg2; 
  if (arg1) (arg1)->neurons = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_patch_expert_neurons_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< LandmarkDetector::CCNF_neuron > *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (std::vector< LandmarkDetector::CCNF_neuron > *)& ((arg1)->neurons);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_window_sizes_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->window_sizes = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_patch_expert_window_sizes_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->window_sizes);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_Sigmas_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< cv::Mat_< float > > *arg2 = (std::vector< cv::Mat_< float > > *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (std::vector< cv::Mat_< float > > *)jarg2; 
  if (arg1) (arg1)->Sigmas = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_patch_expert_Sigmas_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< cv::Mat_< float > > *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (std::vector< cv::Mat_< float > > *)& ((arg1)->Sigmas);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_betas_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< double > *arg2 = (std::vector< double > *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (std::vector< double > *)jarg2; 
  if (arg1) (arg1)->betas = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCNF_patch_expert_betas_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (std::vector< double > *)& ((arg1)->betas);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_patch_confidence_set(void * jarg1, double jarg2) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->patch_confidence = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CCNF_patch_expert_patch_confidence_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  result = (double) ((arg1)->patch_confidence);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CCNF_patch_expert__SWIG_0() {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *result = 0 ;
  
  result = (LandmarkDetector::CCNF_patch_expert *)new LandmarkDetector::CCNF_patch_expert();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CCNF_patch_expert__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CCNF_patch_expert *arg1 = 0 ;
  LandmarkDetector::CCNF_patch_expert *result = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::CCNF_patch_expert const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::CCNF_patch_expert *)new LandmarkDetector::CCNF_patch_expert((LandmarkDetector::CCNF_patch_expert const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_Read(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  std::ifstream *arg2 = 0 ;
  std::vector< int > arg3 ;
  SwigValueWrapper< std::vector< std::vector< cv::Mat_< float > > > > arg4 ;
  std::vector< int > *argp3 ;
  std::vector< std::vector< cv::Mat_< float > > > *argp4 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (std::ifstream *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  argp3 = (std::vector< int > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< int >", 0);
    return ;
  }
  arg3 = *argp3; 
  argp4 = (std::vector< std::vector< cv::Mat_< float > > > *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< std::vector< cv::Mat_< float > > >", 0);
    return ;
  }
  arg4 = *argp4; 
  (arg1)->Read(*arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_Response(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->Response(*arg2,*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCNF_patch_expert_ComputeSigmas(void * jarg1, void * jarg2, int jarg3) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  SwigValueWrapper< std::vector< cv::Mat_< float > > > arg2 ;
  int arg3 ;
  std::vector< cv::Mat_< float > > *argp2 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  argp2 = (std::vector< cv::Mat_< float > > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< cv::Mat_< float > >", 0);
    return ;
  }
  arg2 = *argp2; 
  arg3 = (int)jarg3; 
  (arg1)->ComputeSigmas(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CCNF_patch_expert(void * jarg1) {
  LandmarkDetector::CCNF_patch_expert *arg1 = (LandmarkDetector::CCNF_patch_expert *) 0 ;
  
  arg1 = (LandmarkDetector::CCNF_patch_expert *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_validator_type_set(void * jarg1, int jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->validator_type = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_DetectionValidator_validator_type_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (int) ((arg1)->validator_type);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_orientations_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Vec3d > *arg2 = (std::vector< cv::Vec3d > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< cv::Vec3d > *)jarg2; 
  if (arg1) (arg1)->orientations = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_orientations_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Vec3d > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< cv::Vec3d > *)& ((arg1)->orientations);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_paws_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< PAW > *arg2 = (std::vector< PAW > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< PAW > *)jarg2; 
  if (arg1) (arg1)->paws = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_paws_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< PAW > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< PAW > *)& ((arg1)->paws);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_bs_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< double > *arg2 = (std::vector< double > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< double > *)jarg2; 
  if (arg1) (arg1)->bs = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_bs_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< double > *)& ((arg1)->bs);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_ws_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *arg2 = (std::vector< cv::Mat_< double > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< cv::Mat_< double > > *)jarg2; 
  if (arg1) (arg1)->ws = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_ws_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< cv::Mat_< double > > *)& ((arg1)->ws);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_ws_nn_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< double > > > *arg2 = (std::vector< std::vector< cv::Mat_< double > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat_< double > > > *)jarg2; 
  if (arg1) (arg1)->ws_nn = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_ws_nn_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< double > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< cv::Mat_< double > > > *)& ((arg1)->ws_nn);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_activation_fun_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->activation_fun = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_activation_fun_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->activation_fun);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_output_fun_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->output_fun = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_output_fun_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->output_fun);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< std::vector< cv::Mat_< float > > > > > *arg2 = (std::vector< std::vector< std::vector< std::vector< cv::Mat_< float > > > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< std::vector< std::vector< cv::Mat_< float > > > > > *)jarg2; 
  if (arg1) (arg1)->cnn_convolutional_layers = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< std::vector< cv::Mat_< float > > > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< std::vector< std::vector< cv::Mat_< float > > > > > *)& ((arg1)->cnn_convolutional_layers);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_dft_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< std::vector< std::pair< int,cv::Mat_< double > > > > > > *arg2 = (std::vector< std::vector< std::vector< std::vector< std::pair< int,cv::Mat_< double > > > > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< std::vector< std::vector< std::pair< int,cv::Mat_< double > > > > > > *)jarg2; 
  if (arg1) (arg1)->cnn_convolutional_layers_dft = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_dft_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< std::vector< std::pair< int,cv::Mat_< double > > > > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< std::vector< std::vector< std::pair< int,cv::Mat_< double > > > > > > *)& ((arg1)->cnn_convolutional_layers_dft);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_bias_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< float > > > *arg2 = (std::vector< std::vector< std::vector< float > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< std::vector< float > > > *)jarg2; 
  if (arg1) (arg1)->cnn_convolutional_layers_bias = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_convolutional_layers_bias_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< std::vector< float > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< std::vector< float > > > *)& ((arg1)->cnn_convolutional_layers_bias);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_subsampling_layers_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< int > > *arg2 = (std::vector< std::vector< int > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< int > > *)jarg2; 
  if (arg1) (arg1)->cnn_subsampling_layers = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_subsampling_layers_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< int > > *)& ((arg1)->cnn_subsampling_layers);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_weights_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *arg2 = (std::vector< std::vector< cv::Mat_< float > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat_< float > > > *)jarg2; 
  if (arg1) (arg1)->cnn_fully_connected_layers_weights = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_weights_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< cv::Mat_< float > > > *)& ((arg1)->cnn_fully_connected_layers_weights);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_bias_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< float > > *arg2 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< float > > *)jarg2; 
  if (arg1) (arg1)->cnn_fully_connected_layers_bias = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_bias_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< float > > *)& ((arg1)->cnn_fully_connected_layers_bias);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_layer_types_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< int > > *arg2 = (std::vector< std::vector< int > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< int > > *)jarg2; 
  if (arg1) (arg1)->cnn_layer_types = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_layer_types_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< int > > *)& ((arg1)->cnn_layer_types);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_biases_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *arg2 = (std::vector< std::vector< cv::Mat_< float > > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat_< float > > > *)jarg2; 
  if (arg1) (arg1)->cnn_fully_connected_layers_biases = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_cnn_fully_connected_layers_biases_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< std::vector< cv::Mat_< float > > > *)& ((arg1)->cnn_fully_connected_layers_biases);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_mean_images_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *arg2 = (std::vector< cv::Mat_< double > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< cv::Mat_< double > > *)jarg2; 
  if (arg1) (arg1)->mean_images = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_mean_images_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< cv::Mat_< double > > *)& ((arg1)->mean_images);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_standard_deviations_set(void * jarg1, void * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *arg2 = (std::vector< cv::Mat_< double > > *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (std::vector< cv::Mat_< double > > *)jarg2; 
  if (arg1) (arg1)->standard_deviations = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DetectionValidator_standard_deviations_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::vector< cv::Mat_< double > > *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  result = (std::vector< cv::Mat_< double > > *)& ((arg1)->standard_deviations);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DetectionValidator__SWIG_0() {
  void * jresult ;
  LandmarkDetector::DetectionValidator *result = 0 ;
  
  result = (LandmarkDetector::DetectionValidator *)new LandmarkDetector::DetectionValidator();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DetectionValidator__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::DetectionValidator *arg1 = 0 ;
  LandmarkDetector::DetectionValidator *result = 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::DetectionValidator const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::DetectionValidator *)new LandmarkDetector::DetectionValidator((LandmarkDetector::DetectionValidator const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_DetectionValidator_Check(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  double jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  cv::Vec3d *arg2 = 0 ;
  cv::Mat_< uchar > *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  double result;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (cv::Vec3d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  arg3 = (cv::Mat_< uchar > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return 0;
  } 
  result = (double)(arg1)->Check((cv::Vec3d const &)*arg2,(cv::Mat_< uchar > const &)*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DetectionValidator_Read(void * jarg1, char * jarg2) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  std::string arg2 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->Read(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_DetectionValidator_GetViewId(void * jarg1, void * jarg2) {
  int jresult ;
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  cv::Vec3d *arg2 = 0 ;
  int result;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  arg2 = (cv::Vec3d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  result = (int)((LandmarkDetector::DetectionValidator const *)arg1)->GetViewId((cv::Vec3d const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_DetectionValidator(void * jarg1) {
  LandmarkDetector::DetectionValidator *arg1 = (LandmarkDetector::DetectionValidator *) 0 ;
  
  arg1 = (LandmarkDetector::DetectionValidator *)jarg1; 
  delete arg1;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectLandmarksInVideo__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  cv::Mat_< uchar > *arg1 = 0 ;
  CLNF *arg2 = 0 ;
  FaceModelParameters *arg3 = 0 ;
  bool result;
  
  arg1 = (cv::Mat_< uchar > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg2 = (CLNF *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF & type is null", 0);
    return 0;
  } 
  arg3 = (FaceModelParameters *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "FaceModelParameters & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectLandmarksInVideo((cv::Mat_< uchar > const &)*arg1,*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectLandmarksInVideo__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  cv::Mat_< uchar > *arg1 = 0 ;
  cv::Rect_< double > arg2 ;
  CLNF *arg3 = 0 ;
  FaceModelParameters *arg4 = 0 ;
  cv::Rect_< double > const *argp2 ;
  bool result;
  
  arg1 = (cv::Mat_< uchar > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  argp2 = (cv::Rect_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Rect_< double > const", 0);
    return 0;
  }
  arg2 = *argp2; 
  arg3 = (CLNF *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF & type is null", 0);
    return 0;
  } 
  arg4 = (FaceModelParameters *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "FaceModelParameters & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectLandmarksInVideo((cv::Mat_< uchar > const &)*arg1,arg2,*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectLandmarksInImage__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  cv::Mat_< uchar > *arg1 = 0 ;
  CLNF *arg2 = 0 ;
  FaceModelParameters *arg3 = 0 ;
  bool result;
  
  arg1 = (cv::Mat_< uchar > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg2 = (CLNF *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF & type is null", 0);
    return 0;
  } 
  arg3 = (FaceModelParameters *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "FaceModelParameters & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectLandmarksInImage((cv::Mat_< uchar > const &)*arg1,*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectLandmarksInImage__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  cv::Mat_< uchar > *arg1 = 0 ;
  cv::Rect_< double > arg2 ;
  CLNF *arg3 = 0 ;
  FaceModelParameters *arg4 = 0 ;
  cv::Rect_< double > const *argp2 ;
  bool result;
  
  arg1 = (cv::Mat_< uchar > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  argp2 = (cv::Rect_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Rect_< double > const", 0);
    return 0;
  }
  arg2 = *argp2; 
  arg3 = (CLNF *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF & type is null", 0);
    return 0;
  } 
  arg4 = (FaceModelParameters *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "FaceModelParameters & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectLandmarksInImage((cv::Mat_< uchar > const &)*arg1,arg2,*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GetPoseCamera(void * jarg1, double jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  CLNF *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  cv::Vec6d result;
  
  arg1 = (CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = LandmarkDetector::GetPoseCamera((CLNF const &)*arg1,arg2,arg3,arg4,arg5);
  jresult = new cv::Vec6d((const cv::Vec6d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GetPoseWorld(void * jarg1, double jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  CLNF *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  cv::Vec6d result;
  
  arg1 = (CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = LandmarkDetector::GetPoseWorld((CLNF const &)*arg1,arg2,arg3,arg4,arg5);
  jresult = new cv::Vec6d((const cv::Vec6d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GetCorrectedPoseCamera(void * jarg1, double jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  CLNF *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  cv::Vec6d result;
  
  arg1 = (CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = LandmarkDetector::GetCorrectedPoseCamera((CLNF const &)*arg1,arg2,arg3,arg4,arg5);
  jresult = new cv::Vec6d((const cv::Vec6d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_GetCorrectedPoseWorld(void * jarg1, double jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  CLNF *arg1 = 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  cv::Vec6d result;
  
  arg1 = (CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CLNF const & type is null", 0);
    return 0;
  } 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = LandmarkDetector::GetCorrectedPoseWorld((CLNF const &)*arg1,arg2,arg3,arg4,arg5);
  jresult = new cv::Vec6d((const cv::Vec6d &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_pdm_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  PDM arg2 ;
  PDM *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (PDM *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null PDM", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->pdm = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_pdm_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  PDM result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->pdm);
  jresult = new PDM((const PDM &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_patch_experts_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  Patch_experts arg2 ;
  Patch_experts *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (Patch_experts *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null Patch_experts", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->patch_experts = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_patch_experts_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  Patch_experts result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->patch_experts);
  jresult = new Patch_experts((const Patch_experts &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_params_local_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->params_local = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_params_local_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->params_local);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_params_global_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Vec6d arg2 ;
  cv::Vec6d *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Vec6d *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Vec6d", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->params_global = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_params_global_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Vec6d result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->params_global);
  jresult = new cv::Vec6d((const cv::Vec6d &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_hierarchical_models_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< LandmarkDetector::CLNF > *arg2 = (std::vector< LandmarkDetector::CLNF > *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (std::vector< LandmarkDetector::CLNF > *)jarg2; 
  if (arg1) (arg1)->hierarchical_models = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_hierarchical_models_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< LandmarkDetector::CLNF > *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::vector< LandmarkDetector::CLNF > *)& ((arg1)->hierarchical_models);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_hierarchical_model_names_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< std::string > *arg2 = (std::vector< std::string > *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (std::vector< std::string > *)jarg2; 
  if (arg1) (arg1)->hierarchical_model_names = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_hierarchical_model_names_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::vector< std::string > *)& ((arg1)->hierarchical_model_names);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_hierarchical_mapping_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< std::vector< std::pair< int,int > > > *arg2 = (std::vector< std::vector< std::pair< int,int > > > *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (std::vector< std::vector< std::pair< int,int > > > *)jarg2; 
  if (arg1) (arg1)->hierarchical_mapping = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_hierarchical_mapping_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< std::vector< std::pair< int,int > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::vector< std::vector< std::pair< int,int > > > *)& ((arg1)->hierarchical_mapping);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_hierarchical_params_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< FaceModelParameters > *arg2 = (std::vector< FaceModelParameters > *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (std::vector< FaceModelParameters > *)jarg2; 
  if (arg1) (arg1)->hierarchical_params = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_hierarchical_params_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< FaceModelParameters > *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::vector< FaceModelParameters > *)& ((arg1)->hierarchical_params);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_face_detector_HAAR_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::CascadeClassifier arg2 ;
  cv::CascadeClassifier *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::CascadeClassifier *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::CascadeClassifier", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->face_detector_HAAR = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_face_detector_HAAR_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::CascadeClassifier result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->face_detector_HAAR);
  jresult = new cv::CascadeClassifier((const cv::CascadeClassifier &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_face_detector_location_set(void * jarg1, char * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->face_detector_location = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CLNF_face_detector_location_get(void * jarg1) {
  char * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::string *) & ((arg1)->face_detector_location);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_face_detector_HOG_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  dlib::frontal_face_detector arg2 ;
  dlib::frontal_face_detector *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (dlib::frontal_face_detector *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null dlib::frontal_face_detector", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->face_detector_HOG = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_face_detector_HOG_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  dlib::frontal_face_detector result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->face_detector_HOG);
  jresult = new dlib::frontal_face_detector((const dlib::frontal_face_detector &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_landmark_validator_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  LandmarkDetector::DetectionValidator *arg2 = (LandmarkDetector::DetectionValidator *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (LandmarkDetector::DetectionValidator *)jarg2; 
  if (arg1) (arg1)->landmark_validator = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_landmark_validator_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  LandmarkDetector::DetectionValidator *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (LandmarkDetector::DetectionValidator *)& ((arg1)->landmark_validator);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_detection_success_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->detection_success = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CLNF_detection_success_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (bool) ((arg1)->detection_success);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_tracking_initialised_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->tracking_initialised = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CLNF_tracking_initialised_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (bool) ((arg1)->tracking_initialised);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_detection_certainty_set(void * jarg1, double jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->detection_certainty = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CLNF_detection_certainty_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (double) ((arg1)->detection_certainty);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_eye_model_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->eye_model = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CLNF_eye_model_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (bool) ((arg1)->eye_model);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_triangulations_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< cv::Mat_< int > > *arg2 = (std::vector< cv::Mat_< int > > *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (std::vector< cv::Mat_< int > > *)jarg2; 
  if (arg1) (arg1)->triangulations = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_triangulations_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::vector< cv::Mat_< int > > *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (std::vector< cv::Mat_< int > > *)& ((arg1)->triangulations);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_detected_landmarks_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->detected_landmarks = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_detected_landmarks_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->detected_landmarks);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_model_likelihood_set(void * jarg1, double jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->model_likelihood = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CLNF_model_likelihood_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (double) ((arg1)->model_likelihood);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_landmark_likelihoods_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->landmark_likelihoods = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_landmark_likelihoods_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->landmark_likelihoods);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_failures_in_a_row_set(void * jarg1, int jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->failures_in_a_row = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CLNF_failures_in_a_row_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = (int) ((arg1)->failures_in_a_row);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_face_template_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< uchar > arg2 ;
  cv::Mat_< uchar > *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Mat_< uchar > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< uchar >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->face_template = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_face_template_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< uchar > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->face_template);
  jresult = new cv::Mat_< uchar >((const cv::Mat_< uchar > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_preference_det_set(void * jarg1, void * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Point_< double > arg2 ;
  cv::Point_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  argp2 = (cv::Point_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->preference_det = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_preference_det_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Point_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result =  ((arg1)->preference_det);
  jresult = new cv::Point_< double >((const cv::Point_< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CLNF__SWIG_0() {
  void * jresult ;
  LandmarkDetector::CLNF *result = 0 ;
  
  result = (LandmarkDetector::CLNF *)new LandmarkDetector::CLNF();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CLNF__SWIG_1(char * jarg1) {
  void * jresult ;
  std::string arg1 ;
  LandmarkDetector::CLNF *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = (LandmarkDetector::CLNF *)new LandmarkDetector::CLNF(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CLNF__SWIG_2(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = 0 ;
  LandmarkDetector::CLNF *result = 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::CLNF const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::CLNF *)new LandmarkDetector::CLNF((LandmarkDetector::CLNF const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CLNF(void * jarg1) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  delete arg1;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CLNF_DetectLandmarks(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  FaceModelParameters *arg3 = 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (FaceModelParameters *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "FaceModelParameters & type is null", 0);
    return 0;
  } 
  result = (bool)(arg1)->DetectLandmarks((cv::Mat_< uchar > const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_GetShape(void * jarg1, double jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = ((LandmarkDetector::CLNF const *)arg1)->GetShape(arg2,arg3,arg4,arg5);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CLNF_GetBoundingBox(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  cv::Rect_< double > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  result = ((LandmarkDetector::CLNF const *)arg1)->GetBoundingBox();
  jresult = new cv::Rect_< double >((const cv::Rect_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_Reset__SWIG_0(void * jarg1) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  (arg1)->Reset();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_Reset__SWIG_1(void * jarg1, double jarg2, double jarg3) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  double arg2 ;
  double arg3 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  arg2 = (double)jarg2; 
  arg3 = (double)jarg3; 
  (arg1)->Reset(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_Read(void * jarg1, char * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::string arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->Read(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CLNF_Read_CLNF(void * jarg1, char * jarg2) {
  LandmarkDetector::CLNF *arg1 = (LandmarkDetector::CLNF *) 0 ;
  std::string arg2 ;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->Read_CLNF(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_num_optimisation_iteration_set(void * jarg1, int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->num_optimisation_iteration = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_FaceModelParameters_num_optimisation_iteration_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (int) ((arg1)->num_optimisation_iteration);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_limit_pose_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->limit_pose = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_limit_pose_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->limit_pose);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_validate_detections_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->validate_detections = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_validate_detections_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->validate_detections);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_validation_boundary_set(void * jarg1, double jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->validation_boundary = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_FaceModelParameters_validation_boundary_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (double) ((arg1)->validation_boundary);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_small_set(void * jarg1, void * jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->window_sizes_small = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_small_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->window_sizes_small);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_init_set(void * jarg1, void * jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->window_sizes_init = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_init_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->window_sizes_init);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_current_set(void * jarg1, void * jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *arg2 = (std::vector< int > *) 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (std::vector< int > *)jarg2; 
  if (arg1) (arg1)->window_sizes_current = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FaceModelParameters_window_sizes_current_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (std::vector< int > *)& ((arg1)->window_sizes_current);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_face_template_scale_set(void * jarg1, double jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->face_template_scale = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_FaceModelParameters_face_template_scale_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (double) ((arg1)->face_template_scale);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_use_face_template_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->use_face_template = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_use_face_template_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->use_face_template);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_model_location_set(void * jarg1, char * jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->model_location = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_FaceModelParameters_model_location_get(void * jarg1) {
  char * jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (std::string *) & ((arg1)->model_location);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_sigma_set(void * jarg1, double jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->sigma = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_FaceModelParameters_sigma_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (double) ((arg1)->sigma);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_reg_factor_set(void * jarg1, double jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->reg_factor = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_FaceModelParameters_reg_factor_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (double) ((arg1)->reg_factor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_weight_factor_set(void * jarg1, double jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->weight_factor = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_FaceModelParameters_weight_factor_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (double) ((arg1)->weight_factor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_multi_view_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->multi_view = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_multi_view_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->multi_view);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_reinit_video_every_set(void * jarg1, int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->reinit_video_every = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_FaceModelParameters_reinit_video_every_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (int) ((arg1)->reinit_video_every);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_face_detector_location_set(void * jarg1, char * jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (arg1) (arg1)->face_detector_location = *arg2;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_FaceModelParameters_face_detector_location_get(void * jarg1) {
  char * jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (std::string *) & ((arg1)->face_detector_location);
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_curr_face_detector_set(void * jarg1, int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  LandmarkDetector::FaceModelParameters::FaceDetector arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = (LandmarkDetector::FaceModelParameters::FaceDetector)jarg2; 
  if (arg1) (arg1)->curr_face_detector = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_FaceModelParameters_curr_face_detector_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  LandmarkDetector::FaceModelParameters::FaceDetector result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (LandmarkDetector::FaceModelParameters::FaceDetector) ((arg1)->curr_face_detector);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_quiet_mode_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->quiet_mode = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_quiet_mode_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->quiet_mode);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_refine_hierarchical_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->refine_hierarchical = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_refine_hierarchical_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->refine_hierarchical);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_refine_parameters_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->refine_parameters = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_refine_parameters_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->refine_parameters);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FaceModelParameters_track_gaze_set(void * jarg1, unsigned int jarg2) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool arg2 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->track_gaze = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_FaceModelParameters_track_gaze_get(void * jarg1) {
  unsigned int jresult ;
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  bool result;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  result = (bool) ((arg1)->track_gaze);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FaceModelParameters__SWIG_0() {
  void * jresult ;
  LandmarkDetector::FaceModelParameters *result = 0 ;
  
  result = (LandmarkDetector::FaceModelParameters *)new LandmarkDetector::FaceModelParameters();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FaceModelParameters__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::string > *arg1 = 0 ;
  LandmarkDetector::FaceModelParameters *result = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::FaceModelParameters *)new LandmarkDetector::FaceModelParameters(*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_FaceModelParameters(void * jarg1) {
  LandmarkDetector::FaceModelParameters *arg1 = (LandmarkDetector::FaceModelParameters *) 0 ;
  
  arg1 = (LandmarkDetector::FaceModelParameters *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_get_video_input_output_params(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  std::vector< std::string > *arg1 = 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  bool *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::vector< std::string > *arg6 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg2 = (std::vector< std::string > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg3 = (std::vector< std::string > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg4 = (bool *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "bool & type is null", 0);
    return ;
  } 
  arg5 = (std::string *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::string & type is null", 0);
    return ;
  } 
  arg6 = (std::vector< std::string > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  LandmarkDetector::get_video_input_output_params(*arg1,*arg2,*arg3,*arg4,*arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_get_camera_params(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  int *arg1 = 0 ;
  float *arg2 = 0 ;
  float *arg3 = 0 ;
  float *arg4 = 0 ;
  float *arg5 = 0 ;
  std::vector< std::string > *arg6 = 0 ;
  
  arg1 = (int *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "int & type is null", 0);
    return ;
  } 
  arg2 = (float *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "float & type is null", 0);
    return ;
  } 
  arg3 = (float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "float & type is null", 0);
    return ;
  } 
  arg4 = (float *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "float & type is null", 0);
    return ;
  } 
  arg5 = (float *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "float & type is null", 0);
    return ;
  } 
  arg6 = (std::vector< std::string > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  LandmarkDetector::get_camera_params(*arg1,*arg2,*arg3,*arg4,*arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_get_image_input_output_params(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  std::vector< std::string > *arg1 = 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  std::vector< std::string > *arg4 = 0 ;
  std::vector< cv::Rect_< double > > *arg5 = 0 ;
  std::vector< std::string > *arg6 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg2 = (std::vector< std::string > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg3 = (std::vector< std::string > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg4 = (std::vector< std::string > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  arg5 = (std::vector< cv::Rect_< double > > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > & type is null", 0);
    return ;
  } 
  arg6 = (std::vector< std::string > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > & type is null", 0);
    return ;
  } 
  LandmarkDetector::get_image_input_output_params(*arg1,*arg2,*arg3,*arg4,*arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_matchTemplate_m(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, int jarg8) {
  cv::Mat_< float > *arg1 = 0 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Mat *arg3 = 0 ;
  cv::Mat *arg4 = 0 ;
  cv::Mat_< float > *arg5 = 0 ;
  std::map< int,cv::Mat_< double > > *arg6 = 0 ;
  cv::Mat_< float > *arg7 = 0 ;
  int arg8 ;
  
  arg1 = (cv::Mat_< float > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  arg5 = (cv::Mat_< float > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg6 = (std::map< int,cv::Mat_< double > > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< int,cv::Mat_< double > > & type is null", 0);
    return ;
  } 
  arg7 = (cv::Mat_< float > *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  arg8 = (int)jarg8; 
  LandmarkDetector::matchTemplate_m((cv::Mat_< float > const &)*arg1,*arg2,*arg3,*arg4,(cv::Mat_< float > const &)*arg5,*arg6,*arg7,arg8);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AlignShapesKabsch2D(void * jarg1, void * jarg2) {
  void * jresult ;
  cv::Mat_< double > *arg1 = 0 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Matx22d result;
  
  arg1 = (cv::Mat_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::AlignShapesKabsch2D((cv::Mat_< double > const &)*arg1,(cv::Mat_< double > const &)*arg2);
  jresult = new cv::Matx22d((const cv::Matx22d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AlignShapesWithScale(void * jarg1, void * jarg2) {
  void * jresult ;
  cv::Mat_< double > *arg1 = 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  cv::Matx22d result;
  
  arg1 = (cv::Mat_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return 0;
  } 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = LandmarkDetector::AlignShapesWithScale(*arg1,arg2);
  jresult = new cv::Matx22d((const cv::Matx22d &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Project(void * jarg1, void * jarg2, double jarg3, double jarg4, double jarg5, double jarg6) {
  cv::Mat_< double > *arg1 = 0 ;
  cv::Mat_< double > *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  
  arg1 = (cv::Mat_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return ;
  } 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (double)jarg6; 
  LandmarkDetector::Project(*arg1,(cv::Mat_< double > const &)*arg2,arg3,arg4,arg5,arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_DrawBox__SWIG_0(void * jarg1, void * jarg2, void * jarg3, int jarg4, float jarg5, float jarg6, float jarg7, float jarg8) {
  cv::Mat arg1 ;
  cv::Vec6d arg2 ;
  cv::Scalar arg3 ;
  int arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  cv::Mat *argp1 ;
  cv::Vec6d *argp2 ;
  cv::Scalar *argp3 ;
  
  argp1 = (cv::Mat *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg1 = *argp1; 
  argp2 = (cv::Vec6d *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Vec6d", 0);
    return ;
  }
  arg2 = *argp2; 
  argp3 = (cv::Scalar *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Scalar", 0);
    return ;
  }
  arg3 = *argp3; 
  arg4 = (int)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  LandmarkDetector::DrawBox(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CalculateBox(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  void * jresult ;
  cv::Vec6d arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  cv::Vec6d *argp1 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > result;
  
  argp1 = (cv::Vec6d *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Vec6d", 0);
    return 0;
  }
  arg1 = *argp1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  result = LandmarkDetector::CalculateBox(arg1,arg2,arg3,arg4,arg5);
  jresult = new std::vector< std::pair< cv::Point2d,cv::Point2d > >((const std::vector< std::pair< cv::Point2d,cv::Point2d > > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DrawBox__SWIG_1(void * jarg1, void * jarg2, void * jarg3, int jarg4) {
  std::vector< std::pair< cv::Point,cv::Point > > arg1 ;
  cv::Mat arg2 ;
  cv::Scalar arg3 ;
  int arg4 ;
  std::vector< std::pair< cv::Point,cv::Point > > *argp1 ;
  cv::Mat *argp2 ;
  cv::Scalar *argp3 ;
  
  argp1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< std::pair< cv::Point,cv::Point > >", 0);
    return ;
  }
  arg1 = *argp1; 
  argp2 = (cv::Mat *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg2 = *argp2; 
  argp3 = (cv::Scalar *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Scalar", 0);
    return ;
  }
  arg3 = *argp3; 
  arg4 = (int)jarg4; 
  LandmarkDetector::DrawBox(arg1,arg2,arg3,arg4);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CalculateLandmarks__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  cv::Mat_< double > *arg1 = 0 ;
  cv::Mat_< int > *arg2 = 0 ;
  std::vector< cv::Point2d > result;
  
  arg1 = (cv::Mat_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< int > & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::CalculateLandmarks((cv::Mat_< double > const &)*arg1,*arg2);
  jresult = new std::vector< cv::Point2d >((const std::vector< cv::Point2d > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CalculateLandmarks__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::CLNF *arg1 = 0 ;
  std::vector< cv::Point2d > result;
  
  arg1 = (LandmarkDetector::CLNF *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::CLNF & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::CalculateLandmarks(*arg1);
  jresult = new std::vector< cv::Point2d >((const std::vector< cv::Point2d > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DrawLandmarks(void * jarg1, void * jarg2) {
  cv::Mat arg1 ;
  std::vector< cv::Point > arg2 ;
  cv::Mat *argp1 ;
  std::vector< cv::Point > *argp2 ;
  
  argp1 = (cv::Mat *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg1 = *argp1; 
  argp2 = (std::vector< cv::Point > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< cv::Point >", 0);
    return ;
  }
  arg2 = *argp2; 
  LandmarkDetector::DrawLandmarks(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Draw__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  cv::Mat arg1 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Mat_< int > *arg3 = 0 ;
  cv::Mat *argp1 ;
  
  argp1 = (cv::Mat *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg1 = *argp1; 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< int > const & type is null", 0);
    return ;
  } 
  LandmarkDetector::Draw(arg1,(cv::Mat_< double > const &)*arg2,(cv::Mat_< int > const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Draw__SWIG_1(void * jarg1, void * jarg2) {
  cv::Mat arg1 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Mat *argp1 ;
  
  argp1 = (cv::Mat *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg1 = *argp1; 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  LandmarkDetector::Draw(arg1,(cv::Mat_< double > const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Draw__SWIG_2(void * jarg1, void * jarg2) {
  cv::Mat arg1 ;
  LandmarkDetector::CLNF *arg2 = 0 ;
  cv::Mat *argp1 ;
  
  argp1 = (cv::Mat *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat", 0);
    return ;
  }
  arg1 = *argp1; 
  arg2 = (LandmarkDetector::CLNF *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::CLNF const & type is null", 0);
    return ;
  } 
  LandmarkDetector::Draw(arg1,(LandmarkDetector::CLNF const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Euler2RotationMatrix(void * jarg1) {
  void * jresult ;
  cv::Vec3d *arg1 = 0 ;
  cv::Matx33d result;
  
  arg1 = (cv::Vec3d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::Euler2RotationMatrix((cv::Vec3d const &)*arg1);
  jresult = new cv::Matx33d((const cv::Matx33d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RotationMatrix2Euler(void * jarg1) {
  void * jresult ;
  cv::Matx33d *arg1 = 0 ;
  cv::Vec3d result;
  
  arg1 = (cv::Matx33d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Matx33d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::RotationMatrix2Euler((cv::Matx33d const &)*arg1);
  jresult = new cv::Vec3d((const cv::Vec3d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Euler2AxisAngle(void * jarg1) {
  void * jresult ;
  cv::Vec3d *arg1 = 0 ;
  cv::Vec3d result;
  
  arg1 = (cv::Vec3d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::Euler2AxisAngle((cv::Vec3d const &)*arg1);
  jresult = new cv::Vec3d((const cv::Vec3d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AxisAngle2Euler(void * jarg1) {
  void * jresult ;
  cv::Vec3d *arg1 = 0 ;
  cv::Vec3d result;
  
  arg1 = (cv::Vec3d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::AxisAngle2Euler((cv::Vec3d const &)*arg1);
  jresult = new cv::Vec3d((const cv::Vec3d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_AxisAngle2RotationMatrix(void * jarg1) {
  void * jresult ;
  cv::Vec3d *arg1 = 0 ;
  cv::Matx33d result;
  
  arg1 = (cv::Vec3d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec3d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::AxisAngle2RotationMatrix((cv::Vec3d const &)*arg1);
  jresult = new cv::Matx33d((const cv::Matx33d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_RotationMatrix2AxisAngle(void * jarg1) {
  void * jresult ;
  cv::Matx33d *arg1 = 0 ;
  cv::Vec3d result;
  
  arg1 = (cv::Matx33d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Matx33d const & type is null", 0);
    return 0;
  } 
  result = LandmarkDetector::RotationMatrix2AxisAngle((cv::Matx33d const &)*arg1);
  jresult = new cv::Vec3d((const cv::Vec3d &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectFaces__SWIG_0(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< cv::Rect_< double > > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectFaces(*arg1,(cv::Mat_< uchar > const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectFaces__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  std::vector< cv::Rect_< double > > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  cv::CascadeClassifier *arg3 = 0 ;
  bool result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (cv::CascadeClassifier *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::CascadeClassifier & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectFaces(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectSingleFace__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  cv::Rect_< double > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  cv::CascadeClassifier *arg3 = 0 ;
  cv::Point arg4 ;
  cv::Point const *argp4 ;
  bool result;
  
  arg1 = (cv::Rect_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (cv::CascadeClassifier *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::CascadeClassifier & type is null", 0);
    return 0;
  } 
  argp4 = (cv::Point *)jarg4; 
  if (!argp4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point const", 0);
    return 0;
  }
  arg4 = *argp4; 
  result = (bool)LandmarkDetector::DetectSingleFace(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3,arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectSingleFace__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  cv::Rect_< double > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  cv::CascadeClassifier *arg3 = 0 ;
  bool result;
  
  arg1 = (cv::Rect_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (cv::CascadeClassifier *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::CascadeClassifier & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectSingleFace(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectFacesHOG__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  std::vector< cv::Rect_< double > > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  std::vector< double > *arg3 = 0 ;
  bool result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectFacesHOG(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectFacesHOG__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  std::vector< cv::Rect_< double > > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  dlib::frontal_face_detector *arg3 = 0 ;
  std::vector< double > *arg4 = 0 ;
  bool result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (dlib::frontal_face_detector *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "dlib::frontal_face_detector & type is null", 0);
    return 0;
  } 
  arg4 = (std::vector< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectFacesHOG(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectSingleFaceHOG__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  unsigned int jresult ;
  cv::Rect_< double > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  dlib::frontal_face_detector *arg3 = 0 ;
  double *arg4 = 0 ;
  cv::Point arg5 ;
  cv::Point const *argp5 ;
  bool result;
  
  arg1 = (cv::Rect_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (dlib::frontal_face_detector *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "dlib::frontal_face_detector & type is null", 0);
    return 0;
  } 
  arg4 = (double *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "double & type is null", 0);
    return 0;
  } 
  argp5 = (cv::Point *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point const", 0);
    return 0;
  }
  arg5 = *argp5; 
  result = (bool)LandmarkDetector::DetectSingleFaceHOG(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3,*arg4,arg5);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_DetectSingleFaceHOG__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  cv::Rect_< double > *arg1 = 0 ;
  cv::Mat_< uchar > *arg2 = 0 ;
  dlib::frontal_face_detector *arg3 = 0 ;
  double *arg4 = 0 ;
  bool result;
  
  arg1 = (cv::Rect_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > & type is null", 0);
    return 0;
  } 
  arg2 = (cv::Mat_< uchar > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return 0;
  } 
  arg3 = (dlib::frontal_face_detector *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "dlib::frontal_face_detector & type is null", 0);
    return 0;
  } 
  arg4 = (double *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "double & type is null", 0);
    return 0;
  } 
  result = (bool)LandmarkDetector::DetectSingleFaceHOG(*arg1,(cv::Mat_< uchar > const &)*arg2,*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_ReadMatBin(void * jarg1, void * jarg2) {
  std::ifstream *arg1 = 0 ;
  cv::Mat *arg2 = 0 ;
  
  arg1 = (std::ifstream *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  arg2 = (cv::Mat *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  LandmarkDetector::ReadMatBin(*arg1,*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_ReadMat(void * jarg1, void * jarg2) {
  std::ifstream *arg1 = 0 ;
  cv::Mat *arg2 = 0 ;
  
  arg1 = (std::ifstream *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  arg2 = (cv::Mat *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat & type is null", 0);
    return ;
  } 
  LandmarkDetector::ReadMat(*arg1,*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_SkipComments(void * jarg1) {
  std::ifstream *arg1 = 0 ;
  
  arg1 = (std::ifstream *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  LandmarkDetector::SkipComments(*arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_svr_expert_intensity_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< std::vector< Multi_SVR_patch_expert > > > *arg2 = (std::vector< std::vector< std::vector< Multi_SVR_patch_expert > > > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< std::vector< std::vector< Multi_SVR_patch_expert > > > *)jarg2; 
  if (arg1) (arg1)->svr_expert_intensity = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_svr_expert_intensity_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< std::vector< Multi_SVR_patch_expert > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< std::vector< std::vector< Multi_SVR_patch_expert > > > *)& ((arg1)->svr_expert_intensity);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_ccnf_expert_intensity_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< std::vector< LandmarkDetector::CCNF_patch_expert > > > *arg2 = (std::vector< std::vector< std::vector< LandmarkDetector::CCNF_patch_expert > > > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< std::vector< std::vector< LandmarkDetector::CCNF_patch_expert > > > *)jarg2; 
  if (arg1) (arg1)->ccnf_expert_intensity = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_ccnf_expert_intensity_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< std::vector< LandmarkDetector::CCNF_patch_expert > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< std::vector< std::vector< LandmarkDetector::CCNF_patch_expert > > > *)& ((arg1)->ccnf_expert_intensity);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_sigma_components_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *arg2 = (std::vector< std::vector< cv::Mat_< float > > > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat_< float > > > *)jarg2; 
  if (arg1) (arg1)->sigma_components = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_sigma_components_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Mat_< float > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< std::vector< cv::Mat_< float > > > *)& ((arg1)->sigma_components);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_patch_scaling_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< double > *arg2 = (std::vector< double > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< double > *)jarg2; 
  if (arg1) (arg1)->patch_scaling = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_patch_scaling_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< double > *)& ((arg1)->patch_scaling);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_centers_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Vec3d > > *arg2 = (std::vector< std::vector< cv::Vec3d > > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Vec3d > > *)jarg2; 
  if (arg1) (arg1)->centers = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_centers_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Vec3d > > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< std::vector< cv::Vec3d > > *)& ((arg1)->centers);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_visibilities_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Mat_< int > > > *arg2 = (std::vector< std::vector< cv::Mat_< int > > > *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat_< int > > > *)jarg2; 
  if (arg1) (arg1)->visibilities = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Patch_experts_visibilities_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::vector< cv::Mat_< int > > > *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (std::vector< std::vector< cv::Mat_< int > > > *)& ((arg1)->visibilities);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Patch_experts__SWIG_0() {
  void * jresult ;
  LandmarkDetector::Patch_experts *result = 0 ;
  
  result = (LandmarkDetector::Patch_experts *)new LandmarkDetector::Patch_experts();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Patch_experts__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Patch_experts *arg1 = 0 ;
  LandmarkDetector::Patch_experts *result = 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::Patch_experts const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::Patch_experts *)new LandmarkDetector::Patch_experts((LandmarkDetector::Patch_experts const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_Response(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6, void * jarg7, void * jarg8, int jarg9, int jarg10) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< cv::Mat_< float > > *arg2 = 0 ;
  cv::Matx22f *arg3 = 0 ;
  cv::Matx22d *arg4 = 0 ;
  cv::Mat_< uchar > *arg5 = 0 ;
  PDM *arg6 = 0 ;
  cv::Vec6d *arg7 = 0 ;
  cv::Mat_< double > *arg8 = 0 ;
  int arg9 ;
  int arg10 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (std::vector< cv::Mat_< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat_< float > > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Matx22f *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Matx22f & type is null", 0);
    return ;
  } 
  arg4 = (cv::Matx22d *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Matx22d & type is null", 0);
    return ;
  } 
  arg5 = (cv::Mat_< uchar > *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< uchar > const & type is null", 0);
    return ;
  } 
  arg6 = (PDM *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "PDM const & type is null", 0);
    return ;
  } 
  arg7 = (cv::Vec6d *)jarg7;
  if (!arg7) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return ;
  } 
  arg8 = (cv::Mat_< double > *)jarg8;
  if (!arg8) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg9 = (int)jarg9; 
  arg10 = (int)jarg10; 
  (arg1)->Response(*arg2,*arg3,*arg4,(cv::Mat_< uchar > const &)*arg5,(PDM const &)*arg6,(cv::Vec6d const &)*arg7,(cv::Mat_< double > const &)*arg8,arg9,arg10);
}


SWIGEXPORT int SWIGSTDCALL CSharp_Patch_experts_GetViewIdx(void * jarg1, void * jarg2, int jarg3) {
  int jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  cv::Vec6d *arg2 = 0 ;
  int arg3 ;
  int result;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (cv::Vec6d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return 0;
  } 
  arg3 = (int)jarg3; 
  result = (int)((LandmarkDetector::Patch_experts const *)arg1)->GetViewIdx((cv::Vec6d const &)*arg2,arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Patch_experts_nViews__SWIG_0(void * jarg1, unsigned long jarg2) {
  int jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  size_t arg2 ;
  int result;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  arg2 = (size_t)jarg2; 
  result = (int)((LandmarkDetector::Patch_experts const *)arg1)->nViews(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Patch_experts_nViews__SWIG_1(void * jarg1) {
  int jresult ;
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  result = (int)((LandmarkDetector::Patch_experts const *)arg1)->nViews();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Patch_experts_Read(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  std::vector< std::string > arg2 ;
  std::vector< std::string > arg3 ;
  std::vector< std::string > *argp2 ;
  std::vector< std::string > *argp3 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  argp2 = (std::vector< std::string > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< std::string >", 0);
    return ;
  }
  arg2 = *argp2; 
  argp3 = (std::vector< std::string > *)jarg3; 
  if (!argp3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< std::string >", 0);
    return ;
  }
  arg3 = *argp3; 
  (arg1)->Read(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Patch_experts(void * jarg1) {
  LandmarkDetector::Patch_experts *arg1 = (LandmarkDetector::Patch_experts *) 0 ;
  
  arg1 = (LandmarkDetector::Patch_experts *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_mean_shape_set(void * jarg1, void * jarg2) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->mean_shape = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PDM_mean_shape_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  result =  ((arg1)->mean_shape);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_princ_comp_set(void * jarg1, void * jarg2) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->princ_comp = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PDM_princ_comp_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  result =  ((arg1)->princ_comp);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_eigen_values_set(void * jarg1, void * jarg2) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > arg2 ;
  cv::Mat_< double > *argp2 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  argp2 = (cv::Mat_< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< double >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->eigen_values = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_PDM_eigen_values_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > result;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  result =  ((arg1)->eigen_values);
  jresult = new cv::Mat_< double >((const cv::Mat_< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_PDM__SWIG_0() {
  void * jresult ;
  LandmarkDetector::PDM *result = 0 ;
  
  result = (LandmarkDetector::PDM *)new LandmarkDetector::PDM();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_PDM__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::PDM *arg1 = 0 ;
  LandmarkDetector::PDM *result = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::PDM const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::PDM *)new LandmarkDetector::PDM((LandmarkDetector::PDM const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_Read(void * jarg1, char * jarg2) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  std::string arg2 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->Read(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_PDM_NumberOfPoints(void * jarg1) {
  int jresult ;
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  result = (int)((LandmarkDetector::PDM const *)arg1)->NumberOfPoints();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_PDM_NumberOfModes(void * jarg1) {
  int jresult ;
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  result = (int)((LandmarkDetector::PDM const *)arg1)->NumberOfModes();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_Clamp(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Vec6d *arg3 = 0 ;
  LandmarkDetector::FaceModelParameters *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Vec6d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  arg4 = (LandmarkDetector::FaceModelParameters *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::FaceModelParameters const & type is null", 0);
    return ;
  } 
  (arg1)->Clamp(*arg2,*arg3,(LandmarkDetector::FaceModelParameters const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcShape3D(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Mat_< double > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  ((LandmarkDetector::PDM const *)arg1)->CalcShape3D(*arg2,(cv::Mat_< double > const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcShape2D(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< double > *arg2 = 0 ;
  cv::Mat_< double > *arg3 = 0 ;
  cv::Vec6d *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Vec6d *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return ;
  } 
  ((LandmarkDetector::PDM const *)arg1)->CalcShape2D(*arg2,(cv::Mat_< double > const &)*arg3,(cv::Vec6d const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcParams__SWIG_0(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Vec6d *arg2 = 0 ;
  cv::Rect_< double > *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  cv::Vec3d arg5 ;
  cv::Vec3d const *argp5 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Vec6d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  arg3 = (cv::Rect_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  argp5 = (cv::Vec3d *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Vec3d const", 0);
    return ;
  }
  arg5 = *argp5; 
  (arg1)->CalcParams(*arg2,(cv::Rect_< double > const &)*arg3,(cv::Mat_< double > const &)*arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcParams__SWIG_1(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Vec6d *arg2 = 0 ;
  cv::Rect_< double > *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Vec6d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  arg3 = (cv::Rect_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  (arg1)->CalcParams(*arg2,(cv::Rect_< double > const &)*arg3,(cv::Mat_< double > const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcParams__SWIG_2(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Vec6d *arg2 = 0 ;
  cv::Mat_< double > *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  cv::Vec3d arg5 ;
  cv::Vec3d const *argp5 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Vec6d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  argp5 = (cv::Vec3d *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Vec3d const", 0);
    return ;
  }
  arg5 = *argp5; 
  (arg1)->CalcParams(*arg2,(cv::Mat_< double > const &)*arg3,(cv::Mat_< double > const &)*arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcParams__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Vec6d *arg2 = 0 ;
  cv::Mat_< double > *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Vec6d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  (arg1)->CalcParams(*arg2,(cv::Mat_< double > const &)*arg3,(cv::Mat_< double > const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_CalcBoundingBox(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Rect *arg2 = 0 ;
  cv::Vec6d *arg3 = 0 ;
  cv::Mat_< double > *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Rect *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect & type is null", 0);
    return ;
  } 
  arg3 = (cv::Vec6d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< double > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< double > const & type is null", 0);
    return ;
  } 
  (arg1)->CalcBoundingBox(*arg2,(cv::Vec6d const &)*arg3,(cv::Mat_< double > const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_ComputeRigidJacobian(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Vec6d *arg3 = 0 ;
  cv::Mat_< float > *arg4 = 0 ;
  cv::Mat_< float > arg5 ;
  cv::Mat_< float > *arg6 = 0 ;
  cv::Mat_< float > const *argp5 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Vec6d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< float > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  argp5 = (cv::Mat_< float > *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< float > const", 0);
    return ;
  }
  arg5 = *argp5; 
  arg6 = (cv::Mat_< float > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->ComputeRigidJacobian((cv::Mat_< float > const &)*arg2,(cv::Vec6d const &)*arg3,*arg4,arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_ComputeJacobian(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5, void * jarg6) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Vec6d *arg3 = 0 ;
  cv::Mat_< float > *arg4 = 0 ;
  cv::Mat_< float > arg5 ;
  cv::Mat_< float > *arg6 = 0 ;
  cv::Mat_< float > const *argp5 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Vec6d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d const & type is null", 0);
    return ;
  } 
  arg4 = (cv::Mat_< float > *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  argp5 = (cv::Mat_< float > *)jarg5; 
  if (!argp5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< float > const", 0);
    return ;
  }
  arg5 = *argp5; 
  arg6 = (cv::Mat_< float > *)jarg6;
  if (!arg6) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->ComputeJacobian((cv::Mat_< float > const &)*arg2,(cv::Vec6d const &)*arg3,*arg4,arg5,*arg6);
}


SWIGEXPORT void SWIGSTDCALL CSharp_PDM_UpdateModelParameters(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  cv::Vec6d *arg4 = 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  arg4 = (cv::Vec6d *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Vec6d & type is null", 0);
    return ;
  } 
  (arg1)->UpdateModelParameters((cv::Mat_< float > const &)*arg2,*arg3,*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_PDM(void * jarg1) {
  LandmarkDetector::PDM *arg1 = (LandmarkDetector::PDM *) 0 ;
  
  arg1 = (LandmarkDetector::PDM *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_type_set(void * jarg1, int jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->type = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_SVR_patch_expert_type_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result = (int) ((arg1)->type);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_scaling_set(void * jarg1, double jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->scaling = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_SVR_patch_expert_scaling_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result = (double) ((arg1)->scaling);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_bias_set(void * jarg1, double jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->bias = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_SVR_patch_expert_bias_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result = (double) ((arg1)->bias);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_weights_set(void * jarg1, void * jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  cv::Mat_< float > arg2 ;
  cv::Mat_< float > *argp2 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  argp2 = (cv::Mat_< float > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Mat_< float >", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->weights = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SVR_patch_expert_weights_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  cv::Mat_< float > result;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result =  ((arg1)->weights);
  jresult = new cv::Mat_< float >((const cv::Mat_< float > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_weights_dfts_set(void * jarg1, void * jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  std::map< int,cv::Mat_< double >,std::less< int > > *arg2 = (std::map< int,cv::Mat_< double >,std::less< int > > *) 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (std::map< int,cv::Mat_< double >,std::less< int > > *)jarg2; 
  if (arg1) (arg1)->weights_dfts = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_SVR_patch_expert_weights_dfts_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  std::map< int,cv::Mat_< double >,std::less< int > > *result = 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result = (std::map< int,cv::Mat_< double >,std::less< int > > *)& ((arg1)->weights_dfts);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_confidence_set(void * jarg1, double jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double arg2 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (double)jarg2; 
  if (arg1) (arg1)->confidence = arg2;
}


SWIGEXPORT double SWIGSTDCALL CSharp_SVR_patch_expert_confidence_get(void * jarg1) {
  double jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  double result;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  result = (double) ((arg1)->confidence);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SVR_patch_expert__SWIG_0() {
  void * jresult ;
  LandmarkDetector::SVR_patch_expert *result = 0 ;
  
  result = (LandmarkDetector::SVR_patch_expert *)new LandmarkDetector::SVR_patch_expert();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_SVR_patch_expert__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::SVR_patch_expert *arg1 = 0 ;
  LandmarkDetector::SVR_patch_expert *result = 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::SVR_patch_expert const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::SVR_patch_expert *)new LandmarkDetector::SVR_patch_expert((LandmarkDetector::SVR_patch_expert const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_Read(void * jarg1, void * jarg2) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  std::ifstream *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (std::ifstream *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  (arg1)->Read(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_Response(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->Response((cv::Mat_< float > const &)*arg2,*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_SVR_patch_expert_ResponseDepth(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->ResponseDepth((cv::Mat_< float > const &)*arg2,*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_SVR_patch_expert(void * jarg1) {
  LandmarkDetector::SVR_patch_expert *arg1 = (LandmarkDetector::SVR_patch_expert *) 0 ;
  
  arg1 = (LandmarkDetector::SVR_patch_expert *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_width_set(void * jarg1, int jarg2) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->width = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Multi_SVR_patch_expert_width_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  result = (int) ((arg1)->width);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_height_set(void * jarg1, int jarg2) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  int arg2 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->height = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Multi_SVR_patch_expert_height_get(void * jarg1) {
  int jresult ;
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  int result;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  result = (int) ((arg1)->height);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_svr_patch_experts_set(void * jarg1, void * jarg2) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  std::vector< LandmarkDetector::SVR_patch_expert > *arg2 = (std::vector< LandmarkDetector::SVR_patch_expert > *) 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (std::vector< LandmarkDetector::SVR_patch_expert > *)jarg2; 
  if (arg1) (arg1)->svr_patch_experts = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Multi_SVR_patch_expert_svr_patch_experts_get(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  std::vector< LandmarkDetector::SVR_patch_expert > *result = 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  result = (std::vector< LandmarkDetector::SVR_patch_expert > *)& ((arg1)->svr_patch_experts);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Multi_SVR_patch_expert__SWIG_0() {
  void * jresult ;
  LandmarkDetector::Multi_SVR_patch_expert *result = 0 ;
  
  result = (LandmarkDetector::Multi_SVR_patch_expert *)new LandmarkDetector::Multi_SVR_patch_expert();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Multi_SVR_patch_expert__SWIG_1(void * jarg1) {
  void * jresult ;
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = 0 ;
  LandmarkDetector::Multi_SVR_patch_expert *result = 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "LandmarkDetector::Multi_SVR_patch_expert const & type is null", 0);
    return 0;
  } 
  result = (LandmarkDetector::Multi_SVR_patch_expert *)new LandmarkDetector::Multi_SVR_patch_expert((LandmarkDetector::Multi_SVR_patch_expert const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_Read(void * jarg1, void * jarg2) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  std::ifstream *arg2 = 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (std::ifstream *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::ifstream & type is null", 0);
    return ;
  } 
  (arg1)->Read(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_Response(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->Response((cv::Mat_< float > const &)*arg2,*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Multi_SVR_patch_expert_ResponseDepth(void * jarg1, void * jarg2, void * jarg3) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  cv::Mat_< float > *arg2 = 0 ;
  cv::Mat_< float > *arg3 = 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  arg2 = (cv::Mat_< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > const & type is null", 0);
    return ;
  } 
  arg3 = (cv::Mat_< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat_< float > & type is null", 0);
    return ;
  } 
  (arg1)->ResponseDepth((cv::Mat_< float > const &)*arg2,*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Multi_SVR_patch_expert(void * jarg1) {
  LandmarkDetector::Multi_SVR_patch_expert *arg1 = (LandmarkDetector::Multi_SVR_patch_expert *) 0 ;
  
  arg1 = (LandmarkDetector::Multi_SVR_patch_expert *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_Clear(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_Add(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((int const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Int_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Int_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List__SWIG_0() {
  void * jresult ;
  std::vector< int > *result = 0 ;
  
  result = (std::vector< int > *)new std::vector< int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< int > *)new_std_vector_Sl_int_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Int_List_getitemcopy(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int)std_vector_Sl_int_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Int_List_getitem(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int *) &std_vector_Sl_int_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_setitem(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__setitem(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_int_Sg__AddRange(arg1,(std::vector< int > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_Insert(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__Insert(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__InsertRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_int_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List_Repeat(int jarg1, int jarg2) {
  void * jresult ;
  int *arg1 = 0 ;
  int arg2 ;
  int temp1 ;
  std::vector< int > *result = 0 ;
  
  temp1 = (int)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__Repeat((int const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  std_vector_Sl_int_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__SetRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Int_List_Contains(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Contains(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Int_List_IndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__IndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Int_List_LastIndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__LastIndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Int_List_Remove(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Remove(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Int_List(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_Clear(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_Add(void * jarg1, float jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((float const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Float_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type result;
  
  arg1 = (std::vector< float > *)jarg1; 
  result = ((std::vector< float > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Float_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type result;
  
  arg1 = (std::vector< float > *)jarg1; 
  result = ((std::vector< float > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (std::vector< float >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List__SWIG_0() {
  void * jresult ;
  std::vector< float > *result = 0 ;
  
  result = (std::vector< float > *)new std::vector< float >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< float > *arg1 = 0 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< float > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< float > *)new std::vector< float >((std::vector< float > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< float > *)new_std_vector_Sl_float_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Float_List_getitemcopy(void * jarg1, int jarg2) {
  float jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float result;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (float)std_vector_Sl_float_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Float_List_getitem(void * jarg1, int jarg2) {
  float jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float *result = 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (float *) &std_vector_Sl_float_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_setitem(void * jarg1, int jarg2, float jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float *arg3 = 0 ;
  float temp3 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (float)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_float_Sg__setitem(arg1,arg2,(float const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (std::vector< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_float_Sg__AddRange(arg1,(std::vector< float > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< float > *)std_vector_Sl_float_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_Insert(void * jarg1, int jarg2, float jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  float *arg3 = 0 ;
  float temp3 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (float)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_float_Sg__Insert(arg1,arg2,(float const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_float_Sg__InsertRange(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_float_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_float_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List_Repeat(float jarg1, int jarg2) {
  void * jresult ;
  float *arg1 = 0 ;
  int arg2 ;
  float temp1 ;
  std::vector< float > *result = 0 ;
  
  temp1 = (float)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< float > *)std_vector_Sl_float_Sg__Repeat((float const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  std_vector_Sl_float_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_float_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_float_Sg__SetRange(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Float_List_Contains(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  bool result;
  
  arg1 = (std::vector< float > *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_float_Sg__Contains(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Float_List_IndexOf(void * jarg1, float jarg2) {
  int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  int result;
  
  arg1 = (std::vector< float > *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_float_Sg__IndexOf(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Float_List_LastIndexOf(void * jarg1, float jarg2) {
  int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  int result;
  
  arg1 = (std::vector< float > *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_float_Sg__LastIndexOf(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Float_List_Remove(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  bool result;
  
  arg1 = (std::vector< float > *)jarg1; 
  temp2 = (float)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_float_Sg__Remove(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Float_List(void * jarg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  arg1 = (std::vector< float > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_Clear(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_Add(void * jarg1, double jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((double const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Double_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Double_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Double_List__SWIG_0() {
  void * jresult ;
  std::vector< double > *result = 0 ;
  
  result = (std::vector< double > *)new std::vector< double >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Double_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Double_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< double > *)new_std_vector_Sl_double_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_Double_List_getitemcopy(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double result;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (double)std_vector_Sl_double_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_Double_List_getitem(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (double *) &std_vector_Sl_double_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_setitem(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__setitem(arg1,arg2,(double const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_double_Sg__AddRange(arg1,(std::vector< double > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Double_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_Insert(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__Insert(arg1,arg2,(double const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__InsertRange(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_double_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Double_List_Repeat(double jarg1, int jarg2) {
  void * jresult ;
  double *arg1 = 0 ;
  int arg2 ;
  double temp1 ;
  std::vector< double > *result = 0 ;
  
  temp1 = (double)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__Repeat((double const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  std_vector_Sl_double_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__SetRange(arg1,arg2,(std::vector< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Double_List_Contains(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Contains(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Double_List_IndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__IndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Double_List_LastIndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__LastIndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Double_List_Remove(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Remove(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Double_List(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_Clear(void * jarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_Add(void * jarg1, char * jarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->push_back((std::string const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_String_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string >::size_type result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  result = ((std::vector< std::string > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_String_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string >::size_type result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  result = ((std::vector< std::string > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string >::size_type arg2 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (std::vector< std::string >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_String_List__SWIG_0() {
  void * jresult ;
  std::vector< std::string > *result = 0 ;
  
  result = (std::vector< std::string > *)new std::vector< std::string >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_String_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::string > *arg1 = 0 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::string > *)new std::vector< std::string >((std::vector< std::string > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_String_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::string > *)new_std_vector_Sl_std_string_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_String_List_getitemcopy(void * jarg1, int jarg2) {
  char * jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::string result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_string_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_String_List_getitem(void * jarg1, int jarg2) {
  char * jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::string *result = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::string *) &std_vector_Sl_std_string_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_setitem(void * jarg1, int jarg2, char * jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_string_Sg__setitem(arg1,arg2,(std::string const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (std::vector< std::string > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_string_Sg__AddRange(arg1,(std::vector< std::string > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_String_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *result = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::string > *)std_vector_Sl_std_string_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_Insert(void * jarg1, int jarg2, char * jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_string_Sg__Insert(arg1,arg2,(std::string const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::vector< std::string > *arg3 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::string > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_string_Sg__InsertRange(arg1,arg2,(std::vector< std::string > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_string_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_string_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_String_List_Repeat(char * jarg1, int jarg2) {
  void * jresult ;
  std::string *arg1 = 0 ;
  int arg2 ;
  std::vector< std::string > *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::string > *)std_vector_Sl_std_string_Sg__Repeat((std::string const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  std_vector_Sl_std_string_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_string_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_String_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  int arg2 ;
  std::vector< std::string > *arg3 = 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::string > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::string > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_string_Sg__SetRange(arg1,arg2,(std::vector< std::string > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_String_List_Contains(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_vector_Sl_std_string_Sg__Contains(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_String_List_IndexOf(void * jarg1, char * jarg2) {
  int jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::string *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (int)std_vector_Sl_std_string_Sg__IndexOf(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_String_List_LastIndexOf(void * jarg1, char * jarg2) {
  int jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::string *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (int)std_vector_Sl_std_string_Sg__LastIndexOf(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_String_List_Remove(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_vector_Sl_std_string_Sg__Remove(arg1,(std::string const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_String_List(void * jarg1) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  
  arg1 = (std::vector< std::string > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair__SWIG_0() {
  void * jresult ;
  std::pair< cv::Point,cv::Point > *result = 0 ;
  
  result = (std::pair< cv::Point,cv::Point > *)new std::pair< cv::Point,cv::Point >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  cv::Point arg1 ;
  cv::Point arg2 ;
  cv::Point *argp1 ;
  cv::Point *argp2 ;
  std::pair< cv::Point,cv::Point > *result = 0 ;
  
  argp1 = (cv::Point *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point", 0);
    return 0;
  }
  arg1 = *argp1; 
  argp2 = (cv::Point *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (std::pair< cv::Point,cv::Point > *)new std::pair< cv::Point,cv::Point >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point,cv::Point > *arg1 = 0 ;
  std::pair< cv::Point,cv::Point > *result = 0 ;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point,cv::Point > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< cv::Point,cv::Point > *)new std::pair< cv::Point,cv::Point >((std::pair< cv::Point,cv::Point > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_first_set(void * jarg1, void * jarg2) {
  std::pair< cv::Point,cv::Point > *arg1 = (std::pair< cv::Point,cv::Point > *) 0 ;
  cv::Point arg2 ;
  cv::Point *argp2 ;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1; 
  argp2 = (cv::Point *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_first_get(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point,cv::Point > *arg1 = (std::pair< cv::Point,cv::Point > *) 0 ;
  cv::Point result;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1; 
  result =  ((arg1)->first);
  jresult = new cv::Point((const cv::Point &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_second_set(void * jarg1, void * jarg2) {
  std::pair< cv::Point,cv::Point > *arg1 = (std::pair< cv::Point,cv::Point > *) 0 ;
  cv::Point arg2 ;
  cv::Point *argp2 ;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1; 
  argp2 = (cv::Point *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_second_get(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point,cv::Point > *arg1 = (std::pair< cv::Point,cv::Point > *) 0 ;
  cv::Point result;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1; 
  result =  ((arg1)->second);
  jresult = new cv::Point((const cv::Point &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint_Pair(void * jarg1) {
  std::pair< cv::Point,cv::Point > *arg1 = (std::pair< cv::Point,cv::Point > *) 0 ;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_Clear(void * jarg1) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  cv::Point *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (cv::Point *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Point const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  std::vector< cv::Point >::size_type result;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  result = ((std::vector< cv::Point > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  std::vector< cv::Point >::size_type result;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  result = ((std::vector< cv::Point > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  std::vector< cv::Point >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (std::vector< cv::Point >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Point > *result = 0 ;
  
  result = (std::vector< cv::Point > *)new std::vector< cv::Point >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Point > *arg1 = 0 ;
  std::vector< cv::Point > *result = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Point > *)new std::vector< cv::Point >((std::vector< cv::Point > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Point > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Point > *)new_std_vector_Sl_cv_Point_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  cv::Point result;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Point_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Point((const cv::Point &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  cv::Point *result = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Point *) &std_vector_Sl_cv_Point_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  cv::Point *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Point *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point_Sg__setitem(arg1,arg2,(cv::Point const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  std::vector< cv::Point > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (std::vector< cv::Point > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Point_Sg__AddRange(arg1,(std::vector< cv::Point > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Point > *result = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Point > *)std_vector_Sl_cv_Point_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  cv::Point *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Point *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point_Sg__Insert(arg1,arg2,(cv::Point const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  std::vector< cv::Point > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Point > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point_Sg__InsertRange(arg1,arg2,(std::vector< cv::Point > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Point_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Point_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Point *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Point > *result = 0 ;
  
  arg1 = (cv::Point *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Point > *)std_vector_Sl_cv_Point_Sg__Repeat((cv::Point const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  std_vector_Sl_cv_Point_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Point_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  int arg2 ;
  std::vector< cv::Point > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Point > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point_Sg__SetRange(arg1,arg2,(std::vector< cv::Point > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint_List(void * jarg1) {
  std::vector< cv::Point > *arg1 = (std::vector< cv::Point > *) 0 ;
  
  arg1 = (std::vector< cv::Point > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_Clear(void * jarg1) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_Add(void * jarg1, void * jarg2) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  std::pair< cv::Point,cv::Point > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (std::pair< cv::Point,cv::Point > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point,cv::Point > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::pair< cv::Point,cv::Point > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint_Pair_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  std::vector< std::pair< cv::Point,cv::Point > >::size_type result;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  result = ((std::vector< std::pair< cv::Point,cv::Point > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint_Pair_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  std::vector< std::pair< cv::Point,cv::Point > >::size_type result;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  result = ((std::vector< std::pair< cv::Point,cv::Point > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  std::vector< std::pair< cv::Point,cv::Point > >::size_type arg2 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (std::vector< std::pair< cv::Point,cv::Point > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair_List__SWIG_0() {
  void * jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *result = 0 ;
  
  result = (std::vector< std::pair< cv::Point,cv::Point > > *)new std::vector< std::pair< cv::Point,cv::Point > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = 0 ;
  std::vector< std::pair< cv::Point,cv::Point > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point,cv::Point > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::pair< cv::Point,cv::Point > > *)new std::vector< std::pair< cv::Point,cv::Point > >((std::vector< std::pair< cv::Point,cv::Point > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint_Pair_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::pair< cv::Point,cv::Point > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::pair< cv::Point,cv::Point > > *)new_std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point,cv::Point > result;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::pair< cv::Point,cv::Point >((const std::pair< cv::Point,cv::Point > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point,cv::Point > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::pair< cv::Point,cv::Point > *) &std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point,cv::Point > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< cv::Point,cv::Point > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point,cv::Point > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__setitem(arg1,arg2,(std::pair< cv::Point,cv::Point > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point,cv::Point > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__AddRange(arg1,(std::vector< std::pair< cv::Point,cv::Point > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::pair< cv::Point,cv::Point > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::pair< cv::Point,cv::Point > > *)std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point,cv::Point > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< cv::Point,cv::Point > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point,cv::Point > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Insert(arg1,arg2,(std::pair< cv::Point,cv::Point > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point,cv::Point > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::pair< cv::Point,cv::Point > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint_Pair_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::pair< cv::Point,cv::Point > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point,cv::Point > > *result = 0 ;
  
  arg1 = (std::pair< cv::Point,cv::Point > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point,cv::Point > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::pair< cv::Point,cv::Point > > *)std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Repeat((std::pair< cv::Point,cv::Point > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint_Pair_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point,cv::Point > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point,cv::Point > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point_Sc_cv_Point_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::pair< cv::Point,cv::Point > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint_Pair_List(void * jarg1) {
  std::vector< std::pair< cv::Point,cv::Point > > *arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point,cv::Point > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair__SWIG_0() {
  void * jresult ;
  std::pair< cv::Point2d,cv::Point2d > *result = 0 ;
  
  result = (std::pair< cv::Point2d,cv::Point2d > *)new std::pair< cv::Point2d,cv::Point2d >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  cv::Point2d arg1 ;
  cv::Point2d arg2 ;
  cv::Point2d *argp1 ;
  cv::Point2d *argp2 ;
  std::pair< cv::Point2d,cv::Point2d > *result = 0 ;
  
  argp1 = (cv::Point2d *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point2d", 0);
    return 0;
  }
  arg1 = *argp1; 
  argp2 = (cv::Point2d *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point2d", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (std::pair< cv::Point2d,cv::Point2d > *)new std::pair< cv::Point2d,cv::Point2d >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point2d,cv::Point2d > *arg1 = 0 ;
  std::pair< cv::Point2d,cv::Point2d > *result = 0 ;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point2d,cv::Point2d > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< cv::Point2d,cv::Point2d > *)new std::pair< cv::Point2d,cv::Point2d >((std::pair< cv::Point2d,cv::Point2d > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_first_set(void * jarg1, void * jarg2) {
  std::pair< cv::Point2d,cv::Point2d > *arg1 = (std::pair< cv::Point2d,cv::Point2d > *) 0 ;
  cv::Point2d arg2 ;
  cv::Point2d *argp2 ;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1; 
  argp2 = (cv::Point2d *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point2d", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->first = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_first_get(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point2d,cv::Point2d > *arg1 = (std::pair< cv::Point2d,cv::Point2d > *) 0 ;
  cv::Point2d result;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1; 
  result =  ((arg1)->first);
  jresult = new cv::Point2d((const cv::Point2d &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_second_set(void * jarg1, void * jarg2) {
  std::pair< cv::Point2d,cv::Point2d > *arg1 = (std::pair< cv::Point2d,cv::Point2d > *) 0 ;
  cv::Point2d arg2 ;
  cv::Point2d *argp2 ;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1; 
  argp2 = (cv::Point2d *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null cv::Point2d", 0);
    return ;
  }
  arg2 = *argp2; 
  if (arg1) (arg1)->second = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_second_get(void * jarg1) {
  void * jresult ;
  std::pair< cv::Point2d,cv::Point2d > *arg1 = (std::pair< cv::Point2d,cv::Point2d > *) 0 ;
  cv::Point2d result;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1; 
  result =  ((arg1)->second);
  jresult = new cv::Point2d((const cv::Point2d &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint2D_Pair(void * jarg1) {
  std::pair< cv::Point2d,cv::Point2d > *arg1 = (std::pair< cv::Point2d,cv::Point2d > *) 0 ;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_Clear(void * jarg1) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  cv::Point2d *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (cv::Point2d *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point2d const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Point2d const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint2D_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  std::vector< cv::Point2d >::size_type result;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  result = ((std::vector< cv::Point2d > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint2D_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  std::vector< cv::Point2d >::size_type result;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  result = ((std::vector< cv::Point2d > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  std::vector< cv::Point2d >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (std::vector< cv::Point2d >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Point2d > *result = 0 ;
  
  result = (std::vector< cv::Point2d > *)new std::vector< cv::Point2d >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Point2d > *arg1 = 0 ;
  std::vector< cv::Point2d > *result = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point2d > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Point2d > *)new std::vector< cv::Point2d >((std::vector< cv::Point2d > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Point2d > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Point2d > *)new_std_vector_Sl_cv_Point2d_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  cv::Point2d result;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Point2d_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Point2d((const cv::Point2d &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  cv::Point2d *result = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Point2d *) &std_vector_Sl_cv_Point2d_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  cv::Point2d *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Point2d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point2d const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point2d_Sg__setitem(arg1,arg2,(cv::Point2d const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  std::vector< cv::Point2d > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (std::vector< cv::Point2d > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point2d > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Point2d_Sg__AddRange(arg1,(std::vector< cv::Point2d > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Point2d > *result = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Point2d > *)std_vector_Sl_cv_Point2d_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  cv::Point2d *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Point2d *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point2d const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point2d_Sg__Insert(arg1,arg2,(cv::Point2d const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  std::vector< cv::Point2d > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Point2d > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point2d > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point2d_Sg__InsertRange(arg1,arg2,(std::vector< cv::Point2d > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Point2d_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Point2d_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Point2d *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Point2d > *result = 0 ;
  
  arg1 = (cv::Point2d *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Point2d const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Point2d > *)std_vector_Sl_cv_Point2d_Sg__Repeat((cv::Point2d const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  std_vector_Sl_cv_Point2d_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Point2d_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  int arg2 ;
  std::vector< cv::Point2d > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Point2d > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Point2d > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Point2d_Sg__SetRange(arg1,arg2,(std::vector< cv::Point2d > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint2D_List(void * jarg1) {
  std::vector< cv::Point2d > *arg1 = (std::vector< cv::Point2d > *) 0 ;
  
  arg1 = (std::vector< cv::Point2d > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Clear(void * jarg1) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Add(void * jarg1, void * jarg2) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  std::pair< cv::Point2d,cv::Point2d > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (std::pair< cv::Point2d,cv::Point2d > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point2d,cv::Point2d > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::pair< cv::Point2d,cv::Point2d > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint2D_Pair_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > >::size_type result;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  result = ((std::vector< std::pair< cv::Point2d,cv::Point2d > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVPoint2D_Pair_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > >::size_type result;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  result = ((std::vector< std::pair< cv::Point2d,cv::Point2d > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > >::size_type arg2 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (std::vector< std::pair< cv::Point2d,cv::Point2d > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair_List__SWIG_0() {
  void * jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *result = 0 ;
  
  result = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)new std::vector< std::pair< cv::Point2d,cv::Point2d > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = 0 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point2d,cv::Point2d > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)new std::vector< std::pair< cv::Point2d,cv::Point2d > >((std::vector< std::pair< cv::Point2d,cv::Point2d > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVPoint2D_Pair_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)new_std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point2d,cv::Point2d > result;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::pair< cv::Point2d,cv::Point2d >((const std::pair< cv::Point2d,cv::Point2d > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point2d,cv::Point2d > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::pair< cv::Point2d,cv::Point2d > *) &std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point2d,cv::Point2d > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< cv::Point2d,cv::Point2d > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point2d,cv::Point2d > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__setitem(arg1,arg2,(std::pair< cv::Point2d,cv::Point2d > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point2d,cv::Point2d > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__AddRange(arg1,(std::vector< std::pair< cv::Point2d,cv::Point2d > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *result = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::pair< cv::Point2d,cv::Point2d > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::pair< cv::Point2d,cv::Point2d > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point2d,cv::Point2d > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Insert(arg1,arg2,(std::pair< cv::Point2d,cv::Point2d > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point2d,cv::Point2d > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::pair< cv::Point2d,cv::Point2d > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::pair< cv::Point2d,cv::Point2d > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *result = 0 ;
  
  arg1 = (std::pair< cv::Point2d,cv::Point2d > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< cv::Point2d,cv::Point2d > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Repeat((std::pair< cv::Point2d,cv::Point2d > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVPoint2D_Pair_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  int arg2 ;
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::pair< cv::Point2d,cv::Point2d > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_pair_Sl_cv_Point2d_Sc_cv_Point2d_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::pair< cv::Point2d,cv::Point2d > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVPoint2D_Pair_List(void * jarg1) {
  std::vector< std::pair< cv::Point2d,cv::Point2d > > *arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *) 0 ;
  
  arg1 = (std::vector< std::pair< cv::Point2d,cv::Point2d > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_Clear(void * jarg1) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  cv::Rect_< double > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (cv::Rect_< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Rect_< double > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVDoubleRect_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  std::vector< cv::Rect_< double > >::size_type result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  result = ((std::vector< cv::Rect_< double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CVDoubleRect_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  std::vector< cv::Rect_< double > >::size_type result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  result = ((std::vector< cv::Rect_< double > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  std::vector< cv::Rect_< double > >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (std::vector< cv::Rect_< double > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVDoubleRect_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Rect_< double > > *result = 0 ;
  
  result = (std::vector< cv::Rect_< double > > *)new std::vector< cv::Rect_< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVDoubleRect_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Rect_< double > > *arg1 = 0 ;
  std::vector< cv::Rect_< double > > *result = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Rect_< double > > *)new std::vector< cv::Rect_< double > >((std::vector< cv::Rect_< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_CVDoubleRect_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Rect_< double > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Rect_< double > > *)new_std_vector_Sl_cv_Rect__Sl_double_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVDoubleRect_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  cv::Rect_< double > result;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Rect_< double >((const cv::Rect_< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVDoubleRect_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  cv::Rect_< double > *result = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Rect_< double > *) &std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  cv::Rect_< double > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Rect_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__setitem(arg1,arg2,(cv::Rect_< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  std::vector< cv::Rect_< double > > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (std::vector< cv::Rect_< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__AddRange(arg1,(std::vector< cv::Rect_< double > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVDoubleRect_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Rect_< double > > *result = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Rect_< double > > *)std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  cv::Rect_< double > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Rect_< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Insert(arg1,arg2,(cv::Rect_< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  std::vector< cv::Rect_< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Rect_< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__InsertRange(arg1,arg2,(std::vector< cv::Rect_< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CVDoubleRect_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Rect_< double > *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Rect_< double > > *result = 0 ;
  
  arg1 = (cv::Rect_< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Rect_< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Rect_< double > > *)std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Repeat((cv::Rect_< double > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_CVDoubleRect_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  int arg2 ;
  std::vector< cv::Rect_< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Rect_< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Rect_< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Rect__Sl_double_Sg__Sg__SetRange(arg1,arg2,(std::vector< cv::Rect_< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_CVDoubleRect_List(void * jarg1) {
  std::vector< cv::Rect_< double > > *arg1 = (std::vector< cv::Rect_< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Rect_< double > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_Clear(void * jarg1) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (std::vector< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< int > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Int_List2N_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type result;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  result = ((std::vector< std::vector< int > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Int_List2N_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type result;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  result = ((std::vector< std::vector< int > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (std::vector< std::vector< int > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List2N__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< int > > *result = 0 ;
  
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List2N__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< int > > *arg1 = 0 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< int > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >((std::vector< std::vector< int > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_List2N__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< int > > *)new_std_vector_Sl_std_vector_Sl_int_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List2N_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< int > result;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_int_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< int >((const std::vector< int > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List2N_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< int > *) &std_vector_Sl_std_vector_Sl_int_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__setitem(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (std::vector< std::vector< int > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< int > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_int_Sg__Sg__AddRange(arg1,(std::vector< std::vector< int > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List2N_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< int > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__Insert(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_List2N_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< int > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< int > > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< int > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__Repeat((std::vector< int > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_int_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_List2N_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Int_List2N(void * jarg1) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  
  arg1 = (std::vector< std::vector< int > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_Clear(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (std::vector< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< float > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Float_List2N_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  result = ((std::vector< std::vector< float > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Float_List2N_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  result = ((std::vector< std::vector< float > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (std::vector< std::vector< float > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List2N__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< float > > *result = 0 ;
  
  result = (std::vector< std::vector< float > > *)new std::vector< std::vector< float > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List2N__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = 0 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< float > > *)new std::vector< std::vector< float > >((std::vector< std::vector< float > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_List2N__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< float > > *)new_std_vector_Sl_std_vector_Sl_float_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List2N_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > result;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< float >((const std::vector< float > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List2N_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< float > *) &std_vector_Sl_std_vector_Sl_float_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__setitem(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  std::vector< std::vector< float > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (std::vector< std::vector< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_float_Sg__Sg__AddRange(arg1,(std::vector< std::vector< float > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List2N_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< float > > *)std_vector_Sl_std_vector_Sl_float_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< float > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__Insert(arg1,arg2,(std::vector< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_List2N_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< float > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *result = 0 ;
  
  arg1 = (std::vector< float > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< float > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< float > > *)std_vector_Sl_std_vector_Sl_float_Sg__Sg__Repeat((std::vector< float > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_List2N_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_float_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Float_List2N(void * jarg1) {
  std::vector< std::vector< float > > *arg1 = (std::vector< std::vector< float > > *) 0 ;
  
  arg1 = (std::vector< std::vector< float > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_Clear(void * jarg1) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  cv::Mat< float > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (cv::Mat< float > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< float > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Mat< float > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_FloatMat_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  std::vector< cv::Mat< float > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  result = ((std::vector< cv::Mat< float > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_FloatMat_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  std::vector< cv::Mat< float > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  result = ((std::vector< cv::Mat< float > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  std::vector< cv::Mat< float > >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< float > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  result = (std::vector< cv::Mat< float > > *)new std::vector< cv::Mat< float > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Mat< float > > *arg1 = 0 ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Mat< float > > *)new std::vector< cv::Mat< float > >((std::vector< cv::Mat< float > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Mat< float > > *)new_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  cv::Mat< float > result;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Mat< float >((const cv::Mat< float > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  cv::Mat< float > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Mat< float > *) &std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  cv::Mat< float > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__setitem(arg1,arg2,(cv::Mat< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  std::vector< cv::Mat< float > > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__AddRange(arg1,(std::vector< cv::Mat< float > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Mat< float > > *)std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  cv::Mat< float > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< float > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< float > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Insert(arg1,arg2,(cv::Mat< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__InsertRange(arg1,arg2,(std::vector< cv::Mat< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Mat< float > *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  arg1 = (cv::Mat< float > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< float > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< float > > *)std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Repeat((cv::Mat< float > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__SetRange(arg1,arg2,(std::vector< cv::Mat< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_FloatMat_List(void * jarg1) {
  std::vector< cv::Mat< float > > *arg1 = (std::vector< cv::Mat< float > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_Clear(void * jarg1) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  cv::Mat< double > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (cv::Mat< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< double > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Mat< double > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_DoubleMat_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  std::vector< cv::Mat< double > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  result = ((std::vector< cv::Mat< double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_DoubleMat_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  std::vector< cv::Mat< double > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  result = ((std::vector< cv::Mat< double > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  std::vector< cv::Mat< double > >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< double > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  result = (std::vector< cv::Mat< double > > *)new std::vector< cv::Mat< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Mat< double > > *arg1 = 0 ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Mat< double > > *)new std::vector< cv::Mat< double > >((std::vector< cv::Mat< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Mat< double > > *)new_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  cv::Mat< double > result;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Mat< double >((const cv::Mat< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  cv::Mat< double > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Mat< double > *) &std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  cv::Mat< double > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__setitem(arg1,arg2,(cv::Mat< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  std::vector< cv::Mat< double > > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__AddRange(arg1,(std::vector< cv::Mat< double > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Mat< double > > *)std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  cv::Mat< double > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Insert(arg1,arg2,(cv::Mat< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__InsertRange(arg1,arg2,(std::vector< cv::Mat< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Mat< double > *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  arg1 = (cv::Mat< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< double > > *)std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Repeat((cv::Mat< double > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__SetRange(arg1,arg2,(std::vector< cv::Mat< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_DoubleMat_List(void * jarg1) {
  std::vector< cv::Mat< double > > *arg1 = (std::vector< cv::Mat< double > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_Clear(void * jarg1) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_Add(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  cv::Mat< int > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (cv::Mat< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< int > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((cv::Mat< int > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntMat_List_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  std::vector< cv::Mat< int > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  result = ((std::vector< cv::Mat< int > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntMat_List_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  std::vector< cv::Mat< int > >::size_type result;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  result = ((std::vector< cv::Mat< int > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  std::vector< cv::Mat< int > >::size_type arg2 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< int > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List__SWIG_0() {
  void * jresult ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  result = (std::vector< cv::Mat< int > > *)new std::vector< cv::Mat< int > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< cv::Mat< int > > *arg1 = 0 ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< cv::Mat< int > > *)new std::vector< cv::Mat< int > >((std::vector< cv::Mat< int > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< cv::Mat< int > > *)new_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  cv::Mat< int > result;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new cv::Mat< int >((const cv::Mat< int > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  cv::Mat< int > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (cv::Mat< int > *) &std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  cv::Mat< int > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__setitem(arg1,arg2,(cv::Mat< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_AddRange(void * jarg1, void * jarg2) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  std::vector< cv::Mat< int > > *arg2 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< int > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__AddRange(arg1,(std::vector< cv::Mat< int > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< cv::Mat< int > > *)std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  cv::Mat< int > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (cv::Mat< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Insert(arg1,arg2,(cv::Mat< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__InsertRange(arg1,arg2,(std::vector< cv::Mat< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_RemoveAt(void * jarg1, int jarg2) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  cv::Mat< int > *arg1 = 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  arg1 = (cv::Mat< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "cv::Mat< int > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< int > > *)std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Repeat((cv::Mat< int > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_Reverse__SWIG_0(void * jarg1) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__SetRange(arg1,arg2,(std::vector< cv::Mat< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_IntMat_List(void * jarg1) {
  std::vector< cv::Mat< int > > *arg1 = (std::vector< cv::Mat< int > > *) 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_DoubleMat_Map__SWIG_0() {
  void * jresult ;
  std::map< int,cv::Mat< int > > *result = 0 ;
  
  result = (std::map< int,cv::Mat< int > > *)new std::map< int,cv::Mat< int > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Int_DoubleMat_Map__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< int,cv::Mat< int >,std::less< int > > *arg1 = 0 ;
  std::map< int,cv::Mat< int > > *result = 0 ;
  
  arg1 = (std::map< int,cv::Mat< int >,std::less< int > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< int,cv::Mat< int >,std::less< int > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< int,cv::Mat< int > > *)new std::map< int,cv::Mat< int > >((std::map< int,cv::Mat< int >,std::less< int > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Int_DoubleMat_Map_size(void * jarg1) {
  unsigned long jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::size_type result;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  result = ((std::map< int,cv::Mat< int > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Int_DoubleMat_Map_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  bool result;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  result = (bool)((std::map< int,cv::Mat< int > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_DoubleMat_Map_Clear(void * jarg1) {
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_DoubleMat_Map_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *arg2 = 0 ;
  std::map< int,cv::Mat< int > >::key_type temp2 ;
  std::map< int,cv::Mat< int > >::mapped_type *result = 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  temp2 = (std::map< int,cv::Mat< int > >::key_type)jarg2; 
  arg2 = &temp2; 
  try {
    result = (std::map< int,cv::Mat< int > >::mapped_type *) &std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__getitem(arg1,(int const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_DoubleMat_Map_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *arg2 = 0 ;
  std::map< int,cv::Mat< int > >::mapped_type *arg3 = 0 ;
  std::map< int,cv::Mat< int > >::key_type temp2 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  temp2 = (std::map< int,cv::Mat< int > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< int,cv::Mat< int > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< int,cv::Mat< int > >::mapped_type const & type is null", 0);
    return ;
  } 
  std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__setitem(arg1,(int const &)*arg2,(cv::Mat< int > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Int_DoubleMat_Map_ContainsKey(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *arg2 = 0 ;
  std::map< int,cv::Mat< int > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  temp2 = (std::map< int,cv::Mat< int > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__ContainsKey(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_DoubleMat_Map_Add(void * jarg1, int jarg2, void * jarg3) {
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *arg2 = 0 ;
  std::map< int,cv::Mat< int > >::mapped_type *arg3 = 0 ;
  std::map< int,cv::Mat< int > >::key_type temp2 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  temp2 = (std::map< int,cv::Mat< int > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< int,cv::Mat< int > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< int,cv::Mat< int > >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__Add(arg1,(int const &)*arg2,(cv::Mat< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Int_DoubleMat_Map_Remove(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *arg2 = 0 ;
  std::map< int,cv::Mat< int > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  temp2 = (std::map< int,cv::Mat< int > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__Remove(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Int_DoubleMat_Map_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int >,std::less< int > >::iterator *result = 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  result = (std::map< int,cv::Mat< int >,std::less< int > >::iterator *)std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_Int_DoubleMat_Map_get_next_key(void * jarg1, void * jarg2) {
  int jresult ;
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int >,std::less< int > >::iterator *arg2 = (std::map< int,cv::Mat< int >,std::less< int > >::iterator *) 0 ;
  std::map< int,cv::Mat< int > >::key_type *result = 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  arg2 = (std::map< int,cv::Mat< int >,std::less< int > >::iterator *)jarg2; 
  result = (std::map< int,cv::Mat< int > >::key_type *) &std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__get_next_key(arg1,arg2);
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Int_DoubleMat_Map_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  std::map< int,cv::Mat< int >,std::less< int > >::iterator *arg2 = (std::map< int,cv::Mat< int >,std::less< int > >::iterator *) 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  arg2 = (std::map< int,cv::Mat< int >,std::less< int > >::iterator *)jarg2; 
  std_map_Sl_int_Sc_cv_Mat_Sl_int_Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Int_DoubleMat_Map(void * jarg1) {
  std::map< int,cv::Mat< int > > *arg1 = (std::map< int,cv::Mat< int > > *) 0 ;
  
  arg1 = (std::map< int,cv::Mat< int > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_DoubleMat_Map__SWIG_0() {
  void * jresult ;
  std::map< float,cv::Mat< float > > *result = 0 ;
  
  result = (std::map< float,cv::Mat< float > > *)new std::map< float,cv::Mat< float > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Float_DoubleMat_Map__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< float,cv::Mat< float >,std::less< float > > *arg1 = 0 ;
  std::map< float,cv::Mat< float > > *result = 0 ;
  
  arg1 = (std::map< float,cv::Mat< float >,std::less< float > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< float,cv::Mat< float >,std::less< float > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< float,cv::Mat< float > > *)new std::map< float,cv::Mat< float > >((std::map< float,cv::Mat< float >,std::less< float > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Float_DoubleMat_Map_size(void * jarg1) {
  unsigned long jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::size_type result;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  result = ((std::map< float,cv::Mat< float > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Float_DoubleMat_Map_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  bool result;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  result = (bool)((std::map< float,cv::Mat< float > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_DoubleMat_Map_Clear(void * jarg1) {
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_DoubleMat_Map_getitem(void * jarg1, float jarg2) {
  void * jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *arg2 = 0 ;
  std::map< float,cv::Mat< float > >::key_type temp2 ;
  std::map< float,cv::Mat< float > >::mapped_type *result = 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  temp2 = (std::map< float,cv::Mat< float > >::key_type)jarg2; 
  arg2 = &temp2; 
  try {
    result = (std::map< float,cv::Mat< float > >::mapped_type *) &std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__getitem(arg1,(float const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_DoubleMat_Map_setitem(void * jarg1, float jarg2, void * jarg3) {
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *arg2 = 0 ;
  std::map< float,cv::Mat< float > >::mapped_type *arg3 = 0 ;
  std::map< float,cv::Mat< float > >::key_type temp2 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  temp2 = (std::map< float,cv::Mat< float > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< float,cv::Mat< float > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< float,cv::Mat< float > >::mapped_type const & type is null", 0);
    return ;
  } 
  std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__setitem(arg1,(float const &)*arg2,(cv::Mat< float > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Float_DoubleMat_Map_ContainsKey(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *arg2 = 0 ;
  std::map< float,cv::Mat< float > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  temp2 = (std::map< float,cv::Mat< float > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__ContainsKey(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_DoubleMat_Map_Add(void * jarg1, float jarg2, void * jarg3) {
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *arg2 = 0 ;
  std::map< float,cv::Mat< float > >::mapped_type *arg3 = 0 ;
  std::map< float,cv::Mat< float > >::key_type temp2 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  temp2 = (std::map< float,cv::Mat< float > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< float,cv::Mat< float > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< float,cv::Mat< float > >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__Add(arg1,(float const &)*arg2,(cv::Mat< float > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Float_DoubleMat_Map_Remove(void * jarg1, float jarg2) {
  unsigned int jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *arg2 = 0 ;
  std::map< float,cv::Mat< float > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  temp2 = (std::map< float,cv::Mat< float > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__Remove(arg1,(float const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Float_DoubleMat_Map_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float >,std::less< float > >::iterator *result = 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  result = (std::map< float,cv::Mat< float >,std::less< float > >::iterator *)std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_Float_DoubleMat_Map_get_next_key(void * jarg1, void * jarg2) {
  float jresult ;
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float >,std::less< float > >::iterator *arg2 = (std::map< float,cv::Mat< float >,std::less< float > >::iterator *) 0 ;
  std::map< float,cv::Mat< float > >::key_type *result = 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  arg2 = (std::map< float,cv::Mat< float >,std::less< float > >::iterator *)jarg2; 
  result = (std::map< float,cv::Mat< float > >::key_type *) &std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__get_next_key(arg1,arg2);
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Float_DoubleMat_Map_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  std::map< float,cv::Mat< float >,std::less< float > >::iterator *arg2 = (std::map< float,cv::Mat< float >,std::less< float > >::iterator *) 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  arg2 = (std::map< float,cv::Mat< float >,std::less< float > >::iterator *)jarg2; 
  std_map_Sl_float_Sc_cv_Mat_Sl_float_Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Float_DoubleMat_Map(void * jarg1) {
  std::map< float,cv::Mat< float > > *arg1 = (std::map< float,cv::Mat< float > > *) 0 ;
  
  arg1 = (std::map< float,cv::Mat< float > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Double_DoubleMat_Map__SWIG_0() {
  void * jresult ;
  std::map< double,cv::Mat< double > > *result = 0 ;
  
  result = (std::map< double,cv::Mat< double > > *)new std::map< double,cv::Mat< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_Double_DoubleMat_Map__SWIG_1(void * jarg1) {
  void * jresult ;
  std::map< double,cv::Mat< double >,std::less< double > > *arg1 = 0 ;
  std::map< double,cv::Mat< double > > *result = 0 ;
  
  arg1 = (std::map< double,cv::Mat< double >,std::less< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< double,cv::Mat< double >,std::less< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::map< double,cv::Mat< double > > *)new std::map< double,cv::Mat< double > >((std::map< double,cv::Mat< double >,std::less< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_Double_DoubleMat_Map_size(void * jarg1) {
  unsigned long jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::size_type result;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  result = ((std::map< double,cv::Mat< double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Double_DoubleMat_Map_empty(void * jarg1) {
  unsigned int jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  bool result;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  result = (bool)((std::map< double,cv::Mat< double > > const *)arg1)->empty();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_DoubleMat_Map_Clear(void * jarg1) {
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Double_DoubleMat_Map_getitem(void * jarg1, double jarg2) {
  void * jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *arg2 = 0 ;
  std::map< double,cv::Mat< double > >::key_type temp2 ;
  std::map< double,cv::Mat< double > >::mapped_type *result = 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  temp2 = (std::map< double,cv::Mat< double > >::key_type)jarg2; 
  arg2 = &temp2; 
  try {
    result = (std::map< double,cv::Mat< double > >::mapped_type *) &std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__getitem(arg1,(double const &)*arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_DoubleMat_Map_setitem(void * jarg1, double jarg2, void * jarg3) {
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *arg2 = 0 ;
  std::map< double,cv::Mat< double > >::mapped_type *arg3 = 0 ;
  std::map< double,cv::Mat< double > >::key_type temp2 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  temp2 = (std::map< double,cv::Mat< double > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< double,cv::Mat< double > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< double,cv::Mat< double > >::mapped_type const & type is null", 0);
    return ;
  } 
  std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__setitem(arg1,(double const &)*arg2,(cv::Mat< double > const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Double_DoubleMat_Map_ContainsKey(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *arg2 = 0 ;
  std::map< double,cv::Mat< double > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  temp2 = (std::map< double,cv::Mat< double > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__ContainsKey(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_DoubleMat_Map_Add(void * jarg1, double jarg2, void * jarg3) {
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *arg2 = 0 ;
  std::map< double,cv::Mat< double > >::mapped_type *arg3 = 0 ;
  std::map< double,cv::Mat< double > >::key_type temp2 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  temp2 = (std::map< double,cv::Mat< double > >::key_type)jarg2; 
  arg2 = &temp2; 
  arg3 = (std::map< double,cv::Mat< double > >::mapped_type *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::map< double,cv::Mat< double > >::mapped_type const & type is null", 0);
    return ;
  } 
  try {
    std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__Add(arg1,(double const &)*arg2,(cv::Mat< double > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_Double_DoubleMat_Map_Remove(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *arg2 = 0 ;
  std::map< double,cv::Mat< double > >::key_type temp2 ;
  bool result;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  temp2 = (std::map< double,cv::Mat< double > >::key_type)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__Remove(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_Double_DoubleMat_Map_create_iterator_begin(void * jarg1) {
  void * jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double >,std::less< double > >::iterator *result = 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  result = (std::map< double,cv::Mat< double >,std::less< double > >::iterator *)std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__create_iterator_begin(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_Double_DoubleMat_Map_get_next_key(void * jarg1, void * jarg2) {
  double jresult ;
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double >,std::less< double > >::iterator *arg2 = (std::map< double,cv::Mat< double >,std::less< double > >::iterator *) 0 ;
  std::map< double,cv::Mat< double > >::key_type *result = 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  arg2 = (std::map< double,cv::Mat< double >,std::less< double > >::iterator *)jarg2; 
  result = (std::map< double,cv::Mat< double > >::key_type *) &std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__get_next_key(arg1,arg2);
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_Double_DoubleMat_Map_destroy_iterator(void * jarg1, void * jarg2) {
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  std::map< double,cv::Mat< double >,std::less< double > >::iterator *arg2 = (std::map< double,cv::Mat< double >,std::less< double > >::iterator *) 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  arg2 = (std::map< double,cv::Mat< double >,std::less< double > >::iterator *)jarg2; 
  std_map_Sl_double_Sc_cv_Mat_Sl_double_Sg__Sg__destroy_iterator(arg1,arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_Double_DoubleMat_Map(void * jarg1) {
  std::map< double,cv::Mat< double > > *arg1 = (std::map< double,cv::Mat< double > > *) 0 ;
  
  arg1 = (std::map< double,cv::Mat< double > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_Clear(void * jarg1) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  std::vector< cv::Mat< int > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< int > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< cv::Mat< int > > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntMat_List2N_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  std::vector< std::vector< cv::Mat< int > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< int > > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_IntMat_List2N_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  std::vector< std::vector< cv::Mat< int > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< int > > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  std::vector< std::vector< cv::Mat< int > > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< int > > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List2N__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< cv::Mat< int > > > *result = 0 ;
  
  result = (std::vector< std::vector< cv::Mat< int > > > *)new std::vector< std::vector< cv::Mat< int > > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List2N__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = 0 ;
  std::vector< std::vector< cv::Mat< int > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< int > > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< cv::Mat< int > > > *)new std::vector< std::vector< cv::Mat< int > > >((std::vector< std::vector< cv::Mat< int > > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_IntMat_List2N__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< cv::Mat< int > > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< cv::Mat< int > > > *)new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List2N_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > result;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< cv::Mat< int > >((const std::vector< cv::Mat< int > > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List2N_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< int > > *) &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__setitem(arg1,arg2,(std::vector< cv::Mat< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  std::vector< std::vector< cv::Mat< int > > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< int > > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< int > > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__AddRange(arg1,(std::vector< std::vector< cv::Mat< int > > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List2N_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< cv::Mat< int > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< cv::Mat< int > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< int > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< int > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Insert(arg1,arg2,(std::vector< cv::Mat< int > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< int > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< int > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< int > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< cv::Mat< int > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_IntMat_List2N_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< int > > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< int > > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< int > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< int > > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< cv::Mat< int > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Repeat((std::vector< cv::Mat< int > > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_IntMat_List2N_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< int > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< int > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< int > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_int_Sg__Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< cv::Mat< int > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_IntMat_List2N(void * jarg1) {
  std::vector< std::vector< cv::Mat< int > > > *arg1 = (std::vector< std::vector< cv::Mat< int > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< int > > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_Clear(void * jarg1) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  std::vector< cv::Mat< double > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< cv::Mat< double > > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_DoubleMat_List2N_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  std::vector< std::vector< cv::Mat< double > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< double > > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_DoubleMat_List2N_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  std::vector< std::vector< cv::Mat< double > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< double > > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  std::vector< std::vector< cv::Mat< double > > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< double > > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List2N__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< cv::Mat< double > > > *result = 0 ;
  
  result = (std::vector< std::vector< cv::Mat< double > > > *)new std::vector< std::vector< cv::Mat< double > > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List2N__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = 0 ;
  std::vector< std::vector< cv::Mat< double > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< double > > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< cv::Mat< double > > > *)new std::vector< std::vector< cv::Mat< double > > >((std::vector< std::vector< cv::Mat< double > > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_DoubleMat_List2N__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< cv::Mat< double > > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< cv::Mat< double > > > *)new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List2N_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > result;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< cv::Mat< double > >((const std::vector< cv::Mat< double > > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List2N_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< double > > *) &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__setitem(arg1,arg2,(std::vector< cv::Mat< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  std::vector< std::vector< cv::Mat< double > > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< double > > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< double > > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__AddRange(arg1,(std::vector< std::vector< cv::Mat< double > > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List2N_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< cv::Mat< double > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< cv::Mat< double > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Insert(arg1,arg2,(std::vector< cv::Mat< double > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< double > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< double > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< double > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< cv::Mat< double > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_DoubleMat_List2N_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< double > > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< double > > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< double > > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< cv::Mat< double > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Repeat((std::vector< cv::Mat< double > > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_DoubleMat_List2N_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< double > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< double > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< double > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_double_Sg__Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< cv::Mat< double > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_DoubleMat_List2N(void * jarg1) {
  std::vector< std::vector< cv::Mat< double > > > *arg1 = (std::vector< std::vector< cv::Mat< double > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< double > > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_Clear(void * jarg1) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  std::vector< cv::Mat< float > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (std::vector< cv::Mat< float > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< cv::Mat< float > > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_FloatMat_List2N_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  std::vector< std::vector< cv::Mat< float > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< float > > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_FloatMat_List2N_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  std::vector< std::vector< cv::Mat< float > > >::size_type result;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  result = ((std::vector< std::vector< cv::Mat< float > > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  std::vector< std::vector< cv::Mat< float > > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< float > > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List2N__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< cv::Mat< float > > > *result = 0 ;
  
  result = (std::vector< std::vector< cv::Mat< float > > > *)new std::vector< std::vector< cv::Mat< float > > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List2N__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = 0 ;
  std::vector< std::vector< cv::Mat< float > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< float > > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< cv::Mat< float > > > *)new std::vector< std::vector< cv::Mat< float > > >((std::vector< std::vector< cv::Mat< float > > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_new_FloatMat_List2N__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< cv::Mat< float > > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< cv::Mat< float > > > *)new_std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List2N_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > result;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new std::vector< cv::Mat< float > >((const std::vector< cv::Mat< float > > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List2N_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< cv::Mat< float > > *) &std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__setitem(arg1,arg2,(std::vector< cv::Mat< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  std::vector< std::vector< cv::Mat< float > > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (std::vector< std::vector< cv::Mat< float > > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< float > > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__AddRange(arg1,(std::vector< std::vector< cv::Mat< float > > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List2N_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< cv::Mat< float > > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< cv::Mat< float > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< cv::Mat< float > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< cv::Mat< float > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Insert(arg1,arg2,(std::vector< cv::Mat< float > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< float > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< float > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< float > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< cv::Mat< float > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_FloatMat_List2N_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< cv::Mat< float > > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< float > > > *result = 0 ;
  
  arg1 = (std::vector< cv::Mat< float > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< cv::Mat< float > > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< cv::Mat< float > > > *)std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Repeat((std::vector< cv::Mat< float > > const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_FloatMat_List2N_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< cv::Mat< float > > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< cv::Mat< float > > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< cv::Mat< float > > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_cv_Mat_Sl_float_Sg__Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< cv::Mat< float > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_delete_FloatMat_List2N(void * jarg1) {
  std::vector< std::vector< cv::Mat< float > > > *arg1 = (std::vector< std::vector< cv::Mat< float > > > *) 0 ;
  
  arg1 = (std::vector< std::vector< cv::Mat< float > > > *)jarg1; 
  delete arg1;
}


#ifdef __cplusplus
}
#endif

